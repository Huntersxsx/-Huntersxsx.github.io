<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[some easy algorithm01]]></title>
    <url>%2F2018%2F11%2F21%2Fsome-easy-algorithm01%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&ensp;今天刷了几道华为的校招题，网上大都是用C++实现的，而我采用了更为方便的Python，对于我这种很少编程的人来说，还是有些收获的，于是打算把这些题整理一下。 华为校招题NO.1题目输入一串字符串，统计字符串中各字符出现的次数，并将其按照ASCII码递增的顺序输出，输出要求每种字符都先一个一个输出。 样例：输入:eeefgghh输出:efgheghe 源代码123456789101112131415161718192021222324#统计字符个数mystr = input("请输入一串字符:")strnum = &#123;&#125;L0 = list(mystr)L = []#统计每个字符的个数for i in mystr: strnum[i] = mystr.count(i)print(strnum)#将字符串排序L0.sort()mystr = "".join(L0)#按要求进行重排length = len(mystr)while(length&gt;0): for x in strnum.keys(): if strnum[x] &gt; 0: L.append(x) strnum[x] -= 1 length -= 1#列表转字符串result = "".join(L)print(result) 运行结果 NO.2题目给出一个字符串，将重复的字符去除，仅保留第一次出现的字符，且保持去重后的字符在原字符串中的顺序不变。 样例：输入:aabcdfffea输出:abcdfe 源代码1234567#给出一个字符串，将重复的字符去除，仅保留第一次出现的字符，且保持去重后的字符在原字符串中的顺序不变。mystr = input("请输入一串字符:")strdict = &#123;&#125;for i in mystr: strdict[i] = mystr.count(i)result = "".join(strdict.keys())print(result) 运行结果 NO.3题目举行一场8小时的聚会，12：00-20：00，让来访客人事先填好到达的时间和离开的时间，为了掌握聚会期间座位的数目，需要先估计不同时间的最大客人数量。1、以整点计算，比如“12，18”表示12点后13点前到，17点后18点前离开2、按小时区间统计客人数量，需统计[12,13).[13.14)…[19,,20)共8个时间段的客人数3、假设最大邀请100人 样例见运行结果（注意输入的逗号是英文） 源代码12345678910111213141516171819persondict = &#123;'[12,13)':0,'[13,14)':0,'[14,15)':0,'[15,16)':0,'[16,17)':0,'[17,18)':0,'[18,19)':0,'[19,20)':0&#125;timetable = ['[12,13)','[13,14)','[14,15)','[15,16)','[16,17)','[17,18)','[18,19)','[19,20)']mystr = input("请输入到达和离开时间:")[arrive,leave] = mystr.split(',')for i in range(int(arrive)-12,int(leave)-12): persondict[timetable[i]] += 1ans = input("是否还有来宾？[y/n]:")person = 1while(person&lt;100): if ans == 'y': person += 1 mystr = input("请输入到达和离开时间:") [arrive, leave] = mystr.split(',') for i in range(int(arrive) - 12, int(leave) - 12): persondict[timetable[i]] += 1 ans = input("是否还有来宾？[y/n]:") else: breakprint(persondict) 运行结果&lt;img src=”some-easy-algorithm01/NO.3.png” width=600” hegiht=”400” /&gt; NO.4题目请一个在字符串中找出连续最长的数字串，并把这个串的长度返回；如果存在长度相同的连续数字串，返回最后一个连续数字串；如果没有数字，则返回空字符串（“”）而不是NULL 样例见运行结果 源代码123456789101112131415import remystr = input("请输入一个字符串:")L = re.findall('\d+',mystr) #提取所有连续的数字串if(len(L) == 0): maxnum ="\"""\"" #如果没有数字，则返回空字符串（“”） maxlen = 0else: maxnum = L[0] maxlen = len(L[0]) for num in L: if len(num) &gt;= maxlen: maxnum = num maxlen = len(num)print("最长的数字串为:",maxnum)print("长度为:",maxlen) 运行结果&lt;img src=”some-easy-algorithm01/NO.403.png” width=200” hegiht=”120” /&gt; NO.5题目输入两个长整数,输出相乘后的结果 样例见运行结果 源代码1234567891011121314151617181920212223242526#输入两个长整数,输出相乘后的结果num1 = int(input("请输入第一个数:"))num2 = int(input("请输入第二个数:"))#判断结果的正负if ((num1&gt;0) and (num2&gt;0)) or ((num1&lt;0) and (num2&lt;0)): flag = 1else: flag = -1#转为列表处理L1 = list(str(abs(num1)))L2 = list(str(abs(num2)))L1.reverse()L2.reverse()L = []#乘法运算的步骤q = 1for i in L1: s = 0 p = 1 for j in L2: s += int(i)*int(j)*p*q p *= 10 q *= 10 L.append(s)result = sum(L)*flagprint(result) 运行结果 NO.6题目按要求分解字符串，输入两个数M，N；M代表输入的M串字符串，N代表输出的每串字符串的位数，不够补0。 样例输入：2,8， “abc” ,“123456789“,输出：“abc00000”,“12345678“,”90000000” 源代码12345678910111213141516#按要求分解字符串，输入两个数M，N；M代表输入的M串字符串，N代表输出的每串字符串的位数，不够补0。# 例如：输入2,8， “abc” ,“123456789“,则输出为“abc00000”,“12345678“，”90000000”M = int(input("请输入字符串的数目："))N = int(input("请输入每个字符串的长度："))for i in range(M): mystr = input("请输入字符串：") if len(mystr)&gt;N: if len(mystr)%N != 0: mystr = mystr.ljust((int(len(mystr)/N)+1)*N,'0') #result = re.findall(r'.&#123;3&#125;',mystr) result =[] for i in range (int(len(mystr)/N)): result.append(mystr[i*N:(i+1)*N]) else: result = mystr.ljust(N,'0') print("第"+str(i+1)+"个字符串操作后的结果为：",result) 运行结果&lt;img src=”some-easy-algorithm01/NO.6.png” width=350” hegiht=”220” /&gt; NO.7题目输入一个正整数X，在下面的等式左边的数字之间添加+号或者-号，使得等式成立。1 2 3 4 5 6 7 8 9 = X比如：12-34+5-67+89 = 5 1+23+4-5+6-7-8-9 = 5 样例输入：5输出：21 源代码123456789101112131415161718192021222324252627输入一个正整数X，在下面的等式左边的数字之间添加+号或者-号，使得等式成立。 1 2 3 4 5 6 7 8 9 = X 比如： 12-34+5-67+89 = 5 1+23+4-5+6-7-8-9 = 5 请编写程序，统计满足输入整数的所有整数个数。 输入： 正整数，等式右边的数字 输出： 使该等式成立的个数 样例输入：5 样例输出：21思路：动态规划，当前种类=符号位加号的种类+符号为减号的种类+没有符号的种类 ways(before_num,behind_number,temp_result,ex,L)= ways(before_num-1,L[before_num-1],temp_result - behind_number,1,L) + ways(before_num-1,L[before_num-1],temp_result + behind_number,1,L) + ways(before_num-1,L[before_num-1]*pow(10,ex)+behind_number,temp_result,ex+1,L); before_num: 需要判定的符号前面的数字的个数，初始为8 behind_number: 需要判定的符号后面的数字，初始为9 temp_result:方程右边的结果 ex:阶乘数，因为符号有三种可能，加号，减号，或者没有，如果没有，那么ex就用于计算当前值 L:测试列表 def ways(before_num,behind_number,temp_result,ex,L): if before_num == 0: if behind_number == temp_result: #如果最后等式两边相等，方法+1 return 1 else: return 0 else: return ways(before_num-1,L[before_num-1],temp_result - behind_number,1,L) + ways(before_num-1,L[before_num-1],temp_result + behind_number,1,L) + ways(before_num-1,L[before_num-1]*pow(10,ex)+behind_number,temp_result,ex+1,L)X = int(input("请输入一个正整数："))L = list(range(1, 10))print("一共有",ways(len(L)-1,L[-1],X,1,L),"种方法") 运行结果&lt;img src=”some-easy-algorithm01/NO.7.png” width=160” hegiht=”100” /&gt; NO.8题目给定一个字符串，里边可能包含“()”、“[]”、“{}”三种括号，请编写程序检查该字符串中的括号是否成对出现，且嵌套关系正确。true:若括号成对出现且嵌套关系正确，或该字符串中无括号字符；false:若未正确使用括号字符。 样例见运行结果（注意是英文输入） 源代码12345678910111213141516171819202122232425262728import sysmystr = input("请输入一个字符串：")L = ['1']for i in range(len(mystr)): if mystr[i] == ('(' or '[' or '&#123;'): L.append(mystr[i]) elif mystr[i] == ')': if L[-1] == '(': L.pop() else: print('False') sys.exit() elif mystr[i] == ']': if L[-1] == '[': L.pop() else: print('False') sys.exit() elif mystr[i] == '&#125;': if L[-1] == '&#123;': L.pop() else: print('False') sys.exit()if L == ['1']: print('True')else: print('False') 运行结果 NO.9题目给定一个M行N列的矩阵（M*N个格子），每个格子中放着一定数量的苹果。你从左上角的各自开始，只能向下或者向右走，目的地是右下角的格子。每走过一个格子，就把格子上的苹果都收集起来。求你最多能收集到多少苹果。注意：当经过一个格子时，需要一次性把格子里的平安果都拿走。限制条件：1&lt;N,M&lt;=50；每个格子里的苹果数量是0到1000（包含0和1000）.输入包含两部分： 第一部分矩阵的行和列：M, N 接下来输入M行，N列的苹果数量 样例见运行结果 源代码1234567891011121314151617181920212223'''思路：当前位置能够获得的最大苹果数=max(从上面走能够获得最大苹果+从左边走能获得最大苹果）'''def sum_apple(m,n,num): if m==0 and n==0: return num[0][0] elif m==0 and n&gt;0: return num[m][n] + sum_apple(m,n - 1,num) elif m&gt;0 and n==0: return num[m][n] + sum_apple(m - 1,n,num) else: return num[m][n] + max(sum_apple(m,n-1,num),sum_apple(m - 1,n, num))M = int(input("请输入矩阵的行数[0,50]："))N = int(input("请输入矩阵的列数[0,50]："))print("请输入每个格子的苹果数[0,1000]")num = []for i in range(M): temp = [] for j in range(N): temp.append(int(input())) num.append(temp)print("可以获得的最大苹果数是：",sum_apple(M-1,N-1,num)) 运行结果 后记&emsp;&emsp;&ensp;今天就写这么多吧，还是学到了不少东西的。比如正则表达式中{}里面的次数要求是常量，而Python没有定义const类，需要自己定义或另谋出路；对于动态规划问题也有了更深刻的理解，主要是运用递归，可以将复杂的问题简单化；对字符串和列表的操作更加熟练了，并知道了一些以前没有用过的函数用法，果然还是得多练呐😁。&emsp;&emsp;&ensp;继续努力吧！😉]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thousand separator]]></title>
    <url>%2F2018%2F11%2F19%2Fthousand-separator%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&ensp;偶然看到一个简单的算法题，是一个千位分割的问题，就是比如输入12345678，输出12,345,678这种。听说这也是某个企业的面试题，闲来无事就着手实现一下。我先用了C++进行实现，后来换一种思路用了Python实现，最后采用了更为简单的正则表达式，并对负数、小数都加以实现。 C++实现&emsp;&emsp;&ensp;由于笔者是个菜鸡，平时很少编程，C++还是大一的时候学了点皮毛，现在基本忘了差不多了🌚，所以用的很不熟练，下面是我实现千位分割问题的代码，如果有可以改进的地方，欢迎指出😉。 1#include &lt;iostream&gt; using namespace std; int main() &#123; int num,len=0,extra,temp; int level=1; cout &lt;&lt; "请输入一个数："; cin &gt;&gt; num; //计算输入数字的位数 temp = num; while(temp&gt;0) &#123; temp /=10; len++; level *=10; &#125; extra = len%3; //超出3的倍数位的位数 //输出带有千位分隔符的数字 int k=0; while(len&gt;0) &#123; level /=10; cout &lt;&lt; char(num/level+'0'); //输出每一位 num %= level; k++; extra--; len--; if((extra == 0 &amp;&amp; len &gt; 2) || (k == 3 &amp;&amp; len &gt;0)) &#123; cout &lt;&lt; ","; k = 0; &#125; &#125; &#125; 运行结果 Python实现&emsp;&emsp;&ensp;用C++实现这一简单的问题还是要费一点事的，所以我又转用Python进行了实现，这里我主要是把字符串转变为列表进行了处理。 1234567891011num = input("请输入一个数：")L =list(num) #转变为列表num_length = len(num) #数字的位数start = num_length%3 #超出3的倍数位的位数index = list(range(start,num_length,3)) #需要插入","的索引值step =0for i in index: if i &gt;0: L.insert(i+step,',') step = step+1print("".join(L)) #列表转字符串 运行结果 正则表达式实现&emsp;&emsp;&ensp;读者可能已经发现了，我上述代码的实现对输入的数都要求是正数、整数，要实现正数负数，小数整数都能使用的话，还是需要添加部分代码的，于是这里使用正则表达式来进行实现。&emsp;&emsp;&ensp;据说熟练掌握正则表达式可以节省上百行代码🤔，哈哈，由于这里的问题比较简单，不能充分体现出正则表达式的优势。而且Python的正则表达式引擎是用 C 语言写的，所以效率是十分高，并且几乎所有的字符串任务均可用正则表达式来实现，所以掌握正则表达式是十分有必要的，大家有时间可以去学习一波🤓。下面就贴出我的代码： 123456789num = input("请输入一个数：")m = re.search('\.', num)if m == None: #如果是整数 result = re.sub(r"(?&lt;=\d)(?=(\d&#123;3&#125;)+$)", ",", num)else: #如果是小数 inte, dec = re.split('\.', num) #整数、小数分开处理 inte = re.sub(r"(?&lt;=\d)(?=(\d&#123;3&#125;)+$)", ",", inte) result = inte + '.' +dec #合并print(result) 运行结果&emsp;&emsp;&ensp;可以发现，该程序对负数、小数都能实现千分位分割。正则表达式好处自然很明显，劣势就是不易读，如果不是很熟悉的话很难快速理解该表达式的意思，这里 (?&lt;=\d) 的意思是匹配项前面要有数字，而 (?=(\d{3})+$) 的意思是匹配项后面到结束符要有3的倍数个数字，需要注意的是这里的匹配不消耗字符串的内容，所以原本用作替换的sub函数相当于实现了插入的功能。 后记&emsp;&emsp;&ensp;从上面不同方法的实现，可以看出正则表达式在处理字符串方面的优势，由此可见正则表达式是一个十分重要的技能。其实，像千位分割这种常见的操作，Python怎么会没有函数能够一步到位实现呢🤔？果然，查阅资料后发现，format函数就可以实现这一功能。 1print(format(-123456789.12345,',')) 这样就完事啦，是不是非常简单🌚，不过笔者在这里主要是为了强调正则表达式的优势哈哈哈😁，并且这种难读的表达式还需要多多操作啊。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Image Joint]]></title>
    <url>%2F2018%2F11%2F19%2FImage-Joint%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&ensp;最近刚学完数字图像处理这门课程，闲来无事，就想编一个图片拼接的程序，代码很简单，如下 源代码123456789101112131415161718192021222324252627282930313233343536373839404142import PIL.Image as imimport osIMAGES_PATH = '/Users/sunxin/Desktop/jointtst' # 存放图片的文件夹地址IMAGES_FORMAT = ['.jpg', '.JPG','.jpeg', '.JPEG','.png','.PNG'] # 图片扩展名IMAGE_HEIGHT = 400 # 每张小图片的高IMAGE_WIDTH = 400 # 每张小图片的宽IMAGE_ROW = 3 # 合成图片的行IMAGE_COLUMN = 3 # 合成图片的列IMAGE_SAVE_PATH = '/Users/sunxin/Desktop/jointtst/final/nba_logo.jpg' # 图片合成后保存的地址# 获取图片集地址下的所有图片名称image_names = [name for name in os.listdir(IMAGES_PATH) for item in IMAGES_FORMAT if os.path.splitext(name)[1] == item]'''Tips：os.path.splitext()将文件名和扩展名分开os.path.split()返回文件的路径和文件名'''# 若文件夹中所含图片数目不等于期望拼接的图片数目，报错if len(image_names) != IMAGE_ROW * IMAGE_COLUMN: raise ValueError("请核对需要拼接的图片数目！")# 图像拼接函数def Image_joint(): to_image = im.new('RGB', (IMAGE_COLUMN * IMAGE_WIDTH, IMAGE_ROW * IMAGE_HEIGHT)) # 创建一个新图 # 循环遍历，把每张图片按顺序粘贴到对应位置上 for y in range(IMAGE_ROW ): for x in range(IMAGE_COLUMN): from_image = im.open(os.path.join(IMAGES_PATH,image_names[IMAGE_COLUMN * y + x])).resize( (IMAGE_WIDTH, IMAGE_HEIGHT), im.ANTIALIAS) to_image.paste(from_image, (x * IMAGE_WIDTH, y * IMAGE_HEIGHT)) return to_image.save(IMAGE_SAVE_PATH) # 生成新图'''Tips：注意os.path.join和直接使用字符串'+'的区别（少一个'/'）NEAREST（使用最近邻居）BILINEAR（2x2环境中的线性插值）BICUBIC（4x4环境中的三次样条插值）ANTIALIAS（高质量的下采样滤波器）paste函数的参数为(需要修改的图片，粘贴的起始点的横坐标，粘贴的起始点的纵坐标）'''Image_joint() 实现效果&emsp;&emsp;&ensp;我是将九张不同NBA球队的logo拼接成一个九宫格的形式，拼接前，各个文件如下：&emsp;&emsp;&ensp;运行之后，可将新生成的图片保存到final文件夹之下，得到拼接后的图片为：&emsp;&emsp;&ensp;这样就完成了图片的拼接。需要注意的是，这九张图的大小不一定需要完全一样，我的这九张图的分辨率就不一样，程序中用插值法统一将每个图片的大小重新调整为400*400，于是可以很容易对调整后的图片进行操作。不同的插值法得到的效果不一样，这里采用的是高质量的下采样滤波器。由于原来九张图的高和宽原本不一定相同，现在全部调整为400，所以导致了有些logo看起来被拉高或者是拉宽了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bias-variance]]></title>
    <url>%2F2018%2F11%2F18%2Fbias-variance%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&ensp;昨天看书看到了“偏差和方差”这个字眼，想了一会心中没有得出确切的答案，明明前一阵子才在西瓜书中看过相关概念，现在知识点已经模糊，不仅感叹重温的必要性🌚，于是又把书翻出来重看了一遍，并决定把这块知识点写成博客，加强自己的理解和记忆。在写博客的过程中，我又上网查阅了相关的知识点，看了别人的博客，收获了和书中不一样的解释方式，结合图形更易理解，所以啊，写博客还是颇有收获的😁。 基本概念&emsp;&emsp;&ensp;这一部分我参考的是周志华的西瓜书，书中是通过对期望泛化误差的分解，用公式的推导进而解释偏差、方差以及噪声的概念。这里，我不作推导，但仍用书中的符号进行表示，首先给出相关概念的符号表示 符号 含义 $\boldsymbol x$ 测试样本 $ D $ 训练集 $y_D$ $\boldsymbol x$在数据集中的标记 $y$ $\boldsymbol x$的真实标记 $f(\boldsymbol x;D)$ 训练集$D$上学得模型$f$在$\boldsymbol x$上的预测输出 $\hat{f}(\boldsymbol x)$ 期望预测 $var(\boldsymbol x)$ 使用样本数相同的不同训练集产生的方差 $\epsilon^2$ 噪声 $bias^2(\boldsymbol x)$ 偏差 其中，学习算法的期望预测为 \hat{f}(\boldsymbol x) = E_D[f(\boldsymbol x;D)]算法的期望泛化误差为 E(f;D) = E_D[(f(\boldsymbol x;D)-y_D)^2]假定噪声期望为零，即 E_D[y_D-y] = 0对泛化误差进行分解，最终可以得到 E(f;D) = E_D[(f(\boldsymbol x;D)-\hat{f}(\boldsymbol x))^2]+(\hat{f}(\boldsymbol x)-y)^2+E_D[(y_D-y)^2]于是， E(f;D) = bias^2(\boldsymbol x)+var(\boldsymbol x)+\epsilon^2也就是说，泛化误差可以分解为偏差、方差与噪声之和。 再来看偏差、方差、噪声它们各自的含义： 偏差：bias^2(\boldsymbol x)=(\hat{f}(\boldsymbol x)-y)^2度量了学习算法的期望预测与真实结果的偏离程度，刻画了学习算法本身的拟合能力。 方差 ：var(\boldsymbol x)=E_D[(f(\boldsymbol x;D)-\hat{f}(\boldsymbol x))^2]度量了同样大小的训练集的变动所导致的学习性能的变化，刻画了数据扰动所造成的影响。 噪声：\epsilon^2=E_D[(y_D-y)^2]表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，刻画了学习问题本身的难度。&emsp;&emsp;&ensp;综上，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的，为了取得好的泛化性能，需要使偏差较小，能够充分拟合数据，也要使方差较小，使得数据扰动产生的影响小。 &emsp;&emsp;&ensp;以上是我在书中获得的解释，后来我又在某些博客中看到了更加直观的图形解释。&emsp;&emsp;&ensp;如图，我们可以使用靶心图创建偏差和方差的图形可视化。目标的中心是一个完美预测正确值的模型，随着我们远离靶心，我们的预测变得越来越糟，我们可以重复整个模型构建过程，以便在目标上获得许多单独的命中。有时我们会得到很好的训练数据分布，所以我们预测得很好，且接近靶心，而有时我们的训练数据可能充满了异常值或非标准值，导致预测较差，这些不同的实现导致目标上的命中分散。 偏差-方差窘境&emsp;&emsp;&ensp;一般，偏差和方差是有冲突的，称为偏差-方差窘境（bias-variance dilemma）在训练不足时，学习器的拟合能力不够强，训练数据的扰动不足以使学习器产生显著变化，此时偏差主导了泛化错误率。随着训练程度的加深，学习器的拟合能力逐渐增强，训练数据发生的扰动渐渐能被学习器学到，方差逐渐主导了泛化错误率。训练程度充足后，学习器的拟合能力已非常强，训练数据发生的轻微扰动都会导致学习器发生显著的变化，若训练数据自身的、非全局的特性被学习器学到了，则将发生过拟合。下面的这张图正好说明了这点&emsp;&emsp;&ensp;其实，处理偏差和方差实际上是关于处理过度拟合和欠拟合。随着越来越多的参数被添加到模型中，模型的复杂性上升，变化成为我们首要关注的问题，所以方差变大，而偏差则逐渐下降。&emsp;&emsp;&ensp;正如上一节的那张图所示，欠拟合实际上对应的是高偏差，而过拟合对应的又是高方差。而我们的目的是要寻找使得泛化误差取得最小值的那个最佳点，这就需要让偏差和方差在一定程度上折中取值。 偏差-方差折中&emsp;&emsp;&ensp;很多算法都是可以控制训练程度的，比如决策树可以控制层数，神经网络可以控制训练轮数，集成学习的方法可控制基学习器的个数。&emsp;&emsp;&ensp;我看到偏差-方差折中这一概念是在《机器学习实战》这本书中遇到的，那一章节主要讲了回归。书中提到，线性回归容易发生欠拟合，因为它求的是具有最小均方误差的无偏估计，而我们可以在估计中引入一些偏差用来降低预测的均方误差，有一个方法就是局部加权线性回归。这里不作介绍，感兴趣的小伙伴可以阅读《机器学习实战》的8.2节，得出的结论是选取的核越小，模型复杂度就越高，可以增大方差减小偏差。而当模型十分复杂以至于发生了过拟合时，可以采用缩减法，将一些系数进行缩减，可以减少模型的复杂度，降低方差。书中8.3节和8.4节主要介绍了岭回归、lasso法和前向逐步回归法这些缩减方法，并且结合实例进行了分析，感兴趣的小伙伴可以详细阅读。 后记&emsp;&emsp;&ensp;花了点时间，总算对偏差和方差的概念又加深了一遍印象，以后还是要注意温故而知新呐🌝。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Decorate my Blog]]></title>
    <url>%2F2018%2F11%2F16%2FDecorate-my-Blog%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;&ensp;折腾了两天总算把自己的博客装饰地像个样子了🙃，现在就来整理一下借鉴了哪些资料吧。&emsp;&emsp;&ensp;一篇来自CSDN，一篇来自简书，两篇介绍的都是NexT主题的使用，介绍的设置功能比较多，笔者因为懒癌晚期就选了几个自己觉得还不错的进行了实际操作，操作过程中发现两个都有点小毛病，但是结合起来，再加上自己的摸爬滚打，还是可以成功地把自己的博客装饰的像个样的🌚。&emsp;&emsp;&ensp;上面两篇文章提到的网易云跟帖已经关闭，改用了来必力，不过我对此不是很感兴趣……jiathis分享目前也停止了服务，但是百度当然依旧坚挺……多说评论也被勒令停止服务，可以改用Gitment进行评论功能的实现。还有还有，统计全站总访问量的不蒜子，因为七牛强制过期原有的域名，现在也改了操作，不过很简单，直接看解决方法。另外，笔者在设置头像的过程中，跟着上面两篇的介绍虽然设置了美美的头像🤓，但换了一台电脑居然无法显示，于是又借鉴了这篇文章，把问题解决了。&emsp;&emsp;&ensp;还有很多功能都没尝试操作，感兴趣的小伙伴们可以再折腾一波😁。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Chat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[F107 Calculate]]></title>
    <url>%2F2018%2F11%2F14%2FF107-Calculate%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&ensp;首先，要说明的是这只一个很简单的小任务，只涉及到简单的数据处理，界面设计和可执行文件的生成。那么，为什么笔者能长篇大论地写出这么多废话呢🌝，一是刚搭建好自己的博客，心血来潮、三分钟热度，想把自己的第一篇博客写的像个样子🙃，二来也是为了熟悉熟悉Markdown这个很好的写作语言，锻炼锻炼表达能力和总结能力，三来就是因为太闲了，学习是不可能学习的，这辈子都不想学习，只能写写博客找点事做给自己心灵一点安慰🌚。好了，下面就开始说说我这个小任务吧。 背景&emsp;&emsp;&ensp;由于项目设计被随机分到了一个做微波方向的老师那，有了个比较高大上的项目名称——超材料阵列天线及其在射电望远镜中的应用🤔。当然，对于没学过微波、天线等各种专业课的渣渣，拿到这个题目肯定是一脸懵逼🌚，万幸老师了解到我的研究生方向是图像处理，于是给我先分配了一个数据处理的任务。废话不多说，这次的任务是根据按照某种规则存放在文件中已经测得的数据，通过公式计算得到太阳射电指数F107，那么先简单介绍一下这个高大上的名词吧🙃。 关于F107&emsp;&emsp;&ensp;太阳F107指数，就是太阳10.7厘米波长（2800-2840MHz，视无线电环境而定）的射电辐射通量，是表征太阳活动水平的一个重要参量，和黑子的变化具有很高的相关性，足以反映太阳长期活动和日地效应的变化。其单位为S.F.U（太阳流量单位，Solar Flux Unit），1S.F.U=10-22w Hz-1m-2，其一般范围在60到300之间。平均F107指数高于180的年份称为典型的太阳活动峰年，平均F107指数低于90的年份称为典型的太阳活动谷年。因此，常用F107 指数划分太阳活动的总体水平。&emsp;&emsp;&ensp;目前国家气象局卫星气象中心在山东荣成石岛建有能观测F107指数的太阳射电望远镜，定标过程分为三个步骤：第一步： 天线对准太阳跟观测记录数据；每3分钟形成一个数据文件；第二步： 天线偏离太阳两度，并开启噪声源记录3分钟，形成一个文件；第三步： 接收机关闭噪声源，并记录数据3分钟，形成一个文件；&emsp;&emsp;&ensp;执行完上述三步后，噪声源关闭，天线重新对准太阳进行跟踪。上述步骤分别在每天观测的9:00、12:00:和15：00进行三次。&emsp;&emsp;&ensp;然后，我们就可以从每天的观测文件中提取出三个信息量，分别是：$ R_S $（太阳）、$ R_N $（噪声源）、$ R_B $（冷空），再通过公式: S=S_0（R_S—R_B）/（R_N）就可以求得太阳射电流量，其中$ S_0 $为修正系数。&emsp;&emsp;&ensp;说了这么多，你可能一头雾水，没事，我也什么都不懂🌚，但是我们的任务很简单，就是通过简单的文件操作，把测得的数据整理成自己想要的模样，再通过上述提到的非常简单的公式计算出$ S_0$，通过长期的$ S_0 $得到最佳的修正系数，由于老师只给了我几天有用的测量数据 (其实给了一堆，后来发现很多天机器在维修，数据都没有用🙃)，我就直接采取求平均值的方法得到了看似最佳的最佳修正系数🌝，数据多的话可以采用机器学习的方法，当然，不在本文的讨论范围内，最后再把写好的文件生成一个在其他电脑上可执行的exe就OK了(博主用的是Mac，所以生成的是OS系统下的APP，后续也会提及exe和APP的生成方法)。 任务要求及描述&emsp;&emsp;&ensp;现在，我们可以从空间环境预报中心查询到每天的F107指数，然后就可以通过石岛望远镜观测的每天记录数据，求得本望远镜系统的$S_0$参数，并统计长期的$S_0$的稳定性情况，最后求得最佳$S_0$，用于石岛望远镜每天自动计算F107指数。另外，要求有自动导入数据分析功能，即生成一个exe文件，通过选择文件夹的方式导入一天的所有观测数据，直接计算出当天的F107指数$ S $，并显示在屏幕上。&emsp;&emsp;&ensp;那么，我得到的原始数据是什么样的呢？老师给我发了一个文件夹，记录了今年10月1日至11月6日的所有观测数据(emmm，后来发现由于机器故障，只有10月25日至11月6日的数据可用🌚) &emsp;&emsp;&ensp;打开这个文件夹就惊了，竟然包含了7350个txt文件……先来看看这些文件是怎么命名的吧，随便选取一个 &emsp;&emsp;&ensp;前面一串英文是什么？这不重要，我门只需关注中间的一段数字即可，这个文档的数字是20181101144002，表示的是这是2018年11月01日14时40分02秒生成的记录数据文件，文件中包含了大约三分钟的记录数据。我们再将这个文档打开，哇，又是一堆数据，我们截取部分&emsp;&emsp;&ensp;好了，这些数据具体是什么意思呢？我也没关注一共有多少行，反正就是3分钟左右的数据量就是了，显而易见，第一列数据表示的年月日，第二列表示的时分秒，第三列我也不晓得是啥，反正不重要😂，4、5、6列就是我们记录的数据，分别是在2801MHz±5MHz, 4554MHz±5MHz以及9081MHz±5MHz的采集数据，根据之前F107指数的介绍，我们这里只需关注第4列数据，至于最后一列数据，既然用不到，管它干啥🙃。那么，这么多的记录数据，哪些是太阳数据$ R_S $，哪些是噪声源数据$ R_N $，又是哪些是冷空数据$ R_B $呢？咨询过老师得知，每天的9：00：00-9：02：59，12：00：00-12：02：59，15：00：00-15：02：59的所有数据是噪声源数据$ R_N $，9：03：00-9：05：59，12：03：00-12：05：59，15：03：00-15：05：59的所有数据是冷空$ R_B $，其余的所有数据是太阳数据$ R_S $，这下思路就很明了了，只需提取出当天的$ R_S $、$ R_N $和$ R_B $，那么什么问题都不在话下🤓。 思路及实现&emsp;&emsp;&ensp;先给出我的代码，很简单，都是基础的Python，稍微难懂的都加了注释，所以这里就只提个思路就好。由于笔者刚接触Python没多久，所以很多地方都没有优化，写的不好请见谅😉。哦哦，至于老师发给我的那些观测数据，因为老师说那是机密文件🤔，所以我就不上传了吧😂。 数据处理&emsp;&emsp;&ensp;首先，我们要将这些堆杂在一起的文档按日期进行整合，即把属于一天的所有数据合并到一个文件中，形成这样的一种形式&emsp;&emsp;&ensp;实现起来很简单，我代码中的CombFile( )函数就实现了该功能，后来，老师给我说当时给我的文件是特殊情况🌚，以后需要处理的数据如下面这种样式，即已经按日期分类好，但没有进行整合&emsp;&emsp;&ensp;没事，那样更简单，我的CombFile02( )就实现了整合的功能。整合得到当天的testdata之后，那么一切都变得简单了，函数GetR( )将数据进行划分，得到当天所有的$ R_S $、$R_N$和$ R_B $数据，函数calS0( )再根据$ S $和$ S_0 $之间的公式关系，以及官网查得的数据$ S $，即可计算得出当天的$ S_0 $，计算出多天的$S_0$，我们这里就简单地去个平均，作为我们的最佳修正系数，之后，再用函数PredictS( )，也就是calS0( )的逆过程，把最佳修正系数作为当天的$ S_0 $，就可以预测出当天的$ S $，可以和官网公布的数据进行比较，看看误差，当然，由于训练样本太小，仅仅采用取平均的方法，误差肯定有些偏大🌚，没事……笔者不在乎，重在体验😂。&emsp;&emsp;&ensp;哇，到这里数据处理部分就这么结束了？可见这个项目是有多简单🌝，我还在这里兴致勃勃地长篇大论……好了，下面就剩下用户界面和生成一个可执行文件了。 用户界面&emsp;&emsp;&ensp;这里主要用的Python自带的tkinter库，在制图方面很有用，有兴趣的朋友可以自己学习一个。我们这里用到的就很简单了，一个Button产生按钮，filedialog用作显示对话框，提示用户打开文件夹，最后再用messagebox来显示计算结果就OK了。我们运行一下看看是什么样子&emsp;&emsp;&ensp;可以看到出现了一个对话框，然后我们点击对话框中的按钮，就可以进行选择文件夹了&emsp;&emsp;&ensp;随意选取一个文件夹，就可以计算出结果啦！&emsp;&emsp;&ensp;结果是多少不重要，反正是实现了任务要求了🤓。好了一个简单的项目到此就基本结束了，下面就来生成一个可执行的文件，可以用于其他没有安装Python及相关库的上位机中。 生成可执行文件Mac OS系统&emsp;&emsp;&ensp;这一块我是实在不想写的……捣鼓了那么久最后也没捣鼓出来，主要用到的是py2app，看了很多博客、论坛，都是大同小异，可以根据这篇操作一波，当然里面是没有涉及到遇到的各种bug的，如果你能一帆风顺地完成，emmm那么就很简单了😂。期间我遇到了各种奇葩的bug，不知道是环境还是啥问题，找了小伙伴来也没能解决，最后自己一顿骚操作，居然生成了一个APP，把我激动地半天，我还给这个APP加了一个图标，附加了其他相关信息&emsp;&emsp;&ensp;最后发现这玩意只能在我的Mac上运行，在其他的Mac上就GG了🌚，不管了，放弃了，我就是这么懒🙃。&emsp;&emsp;&ensp;有兴趣的小伙伴可以跟着教程操作一波，简书里的这篇文章写的就很详细了，介绍了如何添加图标，加入版本，版权等信息。另外推荐一个网站，里面有很多有趣的图标可供选择。 Windows系统&emsp;&emsp;&ensp;在Mac OS系统下倒腾失败后，我又开始倒腾Windows……查阅相关介绍后，发现在Windows下有两种生成方式，一个就是和py2app很像的py2exe了……网上介绍很简单，但是有心理阴影的我又没搞出来🙃，后来发现py2exe已经十多年没更新了……出各种bug可能也是难免的吧。所以当然就要推荐第二种方法了——pyinstalller，真的是简单又方便，同样，这里也包含了很多命令可以添加图标之类的各种信息。当然，要想把图标做的更完美，还是需要修改一些文件内容的，可以综合参考一下这篇文章和这一篇，最终，我终于生成了一个exe&emsp;&emsp;&ensp;第一张图是文件存放在桌面或者文件夹中的显示图标。第二张图是运行之后的对话窗口，同样具有按钮，细心的小伙伴还会发现在对话窗口的左上角还有一个小太阳，没错，这就是完善图标后的效果，对应的就是第三张图在任务栏中显示的图标，同样也是一个小太阳。于是在Windows下的可执行文件就生成啦。&emsp;&emsp;&ensp;在其他上位机测试过也可以执行，终于完事了……天呐，我实在太菜了，捣鼓了这么久才弄出来🌚，没事，重在折腾…… 后记&emsp;&emsp;&ensp;把可执行文件发给老师之后也就算完成任务了，闲下来的我花了点时间学了点GitHUb，又搭了一个HEXO博客，然后写下了这篇废话连篇的博客。这篇博客断断续续竟然写了两天，真的敬佩那些坚持每周一更的大牛们，而且还是高质量的文章，自己也不晓得能不能坚持……emmm，继续努力吧😂，未来的路还很长，道阻且长，行则将至，共勉。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FirstBlog]]></title>
    <url>%2F2018%2F11%2F13%2FFirstBlog%2F</url>
    <content type="text"><![CDATA[&emsp;哈哈哈，终于把HEXO搭建好啦！！！👏👏👏&emsp;这两天学习了一下Markdown，GitHub的基本操作，并搭建好了HEXO，过会再学习一下HEXO的使用。😉&emsp;几天主要跟着从0开始学习GitHub系列学习的是这篇文章，作者张帅写的很好呐，受益匪浅，作为一个即将毕业的大四🐶，感觉真的是相见恨晚呐。文章写的这么好，想必人一定很帅吧（手动狗头）哈哈哈。&emsp;先说这么多，明早还要早起上一周里唯一的一节课，哈哈，身为大四🐶唯一早起的理由了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Chat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Chat</tag>
      </tags>
  </entry>
</search>
