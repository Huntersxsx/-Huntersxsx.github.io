<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Rasa_bot_demo1]]></title>
    <url>%2F2018%2F12%2F30%2FRasa-bot-demo1%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&ensp;浪了差不多半年时间，最近终于来到上海，开始着手做毕业设计了，笔者的毕设题目是“基于Rasa框架的任务型人机对话系统”，是一个与NLP相关的企业项目。当然，我的毕业设计肯定没有题目看起来的那么高端，因为已经有了框架，我只要学会如何使用就OK了，至于框架中涉及的各种复杂难解的配置以及算法，目前我只需把它们当成“黑匣子”，等知识储备够了再去钻研也不迟。&emsp;&emsp;&ensp;但是……我的老板似乎忘记了我是啥也不会的大四实习生，二话不说就把Rasa的官方文档甩给我让我去看明白🌚，于是我一脸懵逼地看了一个多星期，还是有一大堆内容没看懂，他才算了解我的真实水平，让我边看边做慢慢熟悉……于是我就完成了我的第一个简单的小demo。&emsp;&emsp;&ensp;虽然说着官方文档写的晦涩难懂（其实是我啥也不会，所以才看不懂😂），但是还是很有必要仔细过一遍。Rasa的官方文档主要包含了NLU和Core两部分，里面包含了很多内容，比如NLU中讲述了如何配置相关组件，完成Intent Classification和Entity Extraction，而Core主要讲述了如何利用Policy选择相应的Action，使得bot做出期望的response。对相关名词不太熟悉？没关系，看看这四篇介绍性博客（1、2、3、4），会对你理解任务型机器人有很大的帮助。如果看完这些博客你已经对任务型机器人有了大概的了解，那么你便可以仔细阅读Rasa提供的官方文档了。除此之外，Rasa的Github里的内容也很丰富，你完全可以根据Rasa Stack starter-pack里的步骤一步到位安装好Rasa框架，而不需要根据官方文档所介绍的一步步安装rasa nlu和rasa core。 Demo: Fast Food Order&emsp;&emsp;&ensp;如果你把官方文档大致过了一遍的话，应该就能很轻松地明白我的小demo。我的demo主要完成的就是快餐店点餐时顾客和营业员的简单交流，由于才学了Rasa没多久，所以对话做的简单并且不是很流畅，也没有考虑到“unhappy path”的情况。以下就是我的demo完成的对话效果： 这是Interactive Training之后的结果。可以看出，bot充当了营业员的角色，询问user的点餐需求，然后计算需要支付的金额。不清楚的话就再看一下直接运行的结果吧： 如果还是不清楚，那就建议使用debug模式，这样就可以看清每一步bot接收到哪些信息，又会做出如何的反应。知道了实现效果之后，再来看我的demo中包含了哪些文件。 run.py&emsp;&emsp;&ensp;这个文件中需要关注的是注释的部分，其余忽略即可 123456789#训练NLU： python -m rasa_nlu.train -c nlu_config_tf.yml --data data/nlu_data/ -o models --fixed_model_name nlu --project current --verbose#训练Core： python -m rasa_core.train -d domain.yml -s data/stories_order.md -o models/dialogue#运行对话： python -m rasa_core.run -d models/dialogue -u models/current/nlu#自定义Action： python -m rasa_core_sdk.endpoint --actions actions#加上endpoint后运行对话： python -m rasa_core.run -d models/dialogue -u models/current/nlu --endpoints endpoints.yml#interative training： python -m rasa_core.train interactive -o models/dialogue -d domain.yml -s data/stories_order.md --nlu models/current/nlu --endpoints endpoints.yml#旧版本interative training： python -m rasa_core.train online -o models/dialogue -d domain.yml -s data/stories_order.md --nlu models/current/nlu --endpoints endpoints.yml# Debug模式： python -m rasa_core.run -d models/dialogue -u models/current/nlu --endpoints endpoints.yml --debug#可视化流程(新版本有)： localhost:5005/visualization.html 这些是训练、运行等操作的命令行语句，以及查看interactive trainning中的可视化流程图的网址。需要注意的是各个文件如果存放的位置发生变化，则需要做相应的修改。&emsp;&emsp;&ensp;首先，应该先训练NLU，生成models/current/nlu/文件夹下的内容，接着再执行训练Core的语句，生成models/dialogue/，如果没有自定义的action的话，就可以直接运行对话了，否则，需要先运行 1python -m rasa_core_sdk.endpoint --actions actions 然后再另开一个窗口，运行 1python -m rasa_core.run -d models/dialogue -u models/current/nlu --endpoints endpoints.yml 如果在后面加上—debug，则就进入了debug模式，在debug模式中可以清楚看出每一步bot提取的信息，帮助用户更加清楚core执行的过程，所以在开始用或者出错时强烈推荐使用Debug。运行最后一个命令则可以在interactive trainning模式中随时查看bot的response过程，如下图，帮助更好地理解。 jieba_test.py&emsp;&emsp;&ensp;这个python文件就是用来测试jieba分词的效果的，如果对分词效果不满意，则可以把想要分开的词添加到data\dict\dict_jieba.txt中，然后在nlu_config_tf.yml中标明dictionary_path路径。 nlu_config_tf.yml&emsp;&emsp;&ensp;这是nlu模块的配置文件，详细内容请仔细阅读官方文档的Component Configuration。&emsp;&emsp;&ensp;先看我这个demo中的nlu_config_tf.yml文件内容： 1234567891011language: "zh"pipeline:- name: "tokenizer_jieba" dictionary_path: "./data/dict"- name: "intent_entity_featurizer_regex"- name: "ner_crf"- name: "ner_synonyms"- name: "intent_featurizer_count_vectors" "token_pattern": '(?u)\b\w+\b' #\b:匹配一个单词边界,\w:匹配字母数字,+:匹配一个或多个- name: "intent_classifier_tensorflow_embedding" 表明对话是用中文进行的，采用的是jieba分词，接下来用intent_entity_featurizer_regex创建正则表达式列表，来简化意图分类、实体提取，接着ner_crf是用来标记实体的，而ner_synonyms则用来处理同义词，然后intent_featurizer_count_vectors创建意图分类的词包，作为分类器intent_classifier_tensorflow_embedding的输入，其中，”token_pattern”: ‘(?u)\b\w+\b’ 是指匹配分次后的一个或多个字母或数字。&emsp;&emsp;&ensp;这些组件就够成了我这个demo的pipeline，注意组件的顺序不能随意变动。 nlu_order.md&emsp;&emsp;&ensp;这是训练数据，关于训练数据的格式可以参考官方文档的这一部分。我的nlu_order.md文件中包含了我给各个intent写的多个话术，并且有的话术还包含了entity，这些话术用来和用户输入的语句进行比较，然后将用户输入的语句分类到相应的intent中，从而完成意图分类。这文件中还包含了synonym，可以将提取出的实体都替换成同一个同义词。 domain.yml&emsp;&emsp;&ensp;domain文件中包含了intents、entities、slots、actions、templates，有关domain文件的格式可以参考官方文档的这一部分。 stories_order.md&emsp;&emsp;&ensp;这就是我写的几个简单的小故事，bot就是根据这个故事线走下去的。看完story的格式之后，你应该就会很容易读懂我写的故事。 actions.py&emsp;&emsp;&ensp;这是在自定义action时需要编写的文件，我这里实现的就是计算订单金额的简单功能。在自定义action时，首先需要创建endpoints.yml文件，该文件里的内容可以参考官方文档的这一部分，至于自定义action类的格式，可以参照这一部分。如果你对我编写的action还有疑问，可以看看这里tracker部分包含的内容。由于在action中是不能直接用print输出语句的，所以要想查看每一步的中间输出结果，可以用dispatcher.utter_message()语句，相关介绍在这里。 parse_nlu_data.py&emsp;&emsp;&ensp;这个python文件主要是对nlu的训练数据文档进行一系列的处理，然后用户可以再自己写一些格式相同的话术作为测试集进行测试，只需要把data_dir的值改成测试数据的文件路径即可。最后运行会生成一个Excel文档，包含了测试集的用户输入语句、原始的意图、预测的意图、预测的信心值、预测是否准确、原始提取出的实体信息、预测出的实体信息，如下图所示: 这一部分本质上与对话系统的关系不大，只是用来观察分类的准确性，但其实这个程序也不复杂，我也加了详细的注释，主要涉及的是正则表达式等基本的python操作，感兴趣的小伙伴可以自己看一看。 后记&emsp;&emsp;&ensp;目前，我的毕设工作已经展开了，2018年也来到了尾声，可能我还没有做好迎接新的一年的准备，或许是时候该慢慢收心了，愿自己能够在2019年里踏实科研、学有所成。 2019.1.10更&emsp;&emsp;&ensp;在之前的基础上，我又加了一些简单的功能，使得对话显得更加流畅，现在的功能主要包括：取消已定食物、更改食物数量、更改食物种类、计算价格、处理意外状况等。由于提取数字用到了duckling组件，而duckling需要在Linux或者Mac OS系统中使用，所以我是在Ubantu虚拟机中进行的操作，由于之前没用过Linux系统，所以也趁着这个机会熟悉了一波。总的来说，这周还是学到了不少东西的，所以实习还是很有好处的😆，不仅能学习很多在学校学不到的知识，还吃得好睡得好，而且今天还发工资了😜，真是美哉~&emsp;&emsp;&ensp;一些主要的文件比如action.py，stories_order.md，nlu_order.md，domian.yml等都进行了更改，鉴于此次的更改也不是完全版，所以就不把新的文件上传到Github中了，等毕设完成了再做更新吧😁。下面就放几张这次更新的效果图吧: 2019.1.15更&emsp;&emsp;&ensp;在之前的基础上，又加了一些简单功能。之前的对话其实都可以视为是一次订单中的对话，包括对话中取消已定食物、更改食物数量、更改食物种类等，现在可进行多轮的点餐，新增功能主要包括查看订单、催单、取消订单、修改订单等，看了下面的效果图就一目了然啦。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Aircraft Battle]]></title>
    <url>%2F2018%2F12%2F17%2FAircraft-Battle%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;&ensp;浪了好久……🌚也该收收心了，今天在Github上看到一个用Python编写的打飞机的小游戏，感觉还不错，而且也不长，就花了点时间给大神的代码加了点注释，更加适合Python的新手阅读。&emsp;&emsp;&ensp;Python是一种解释型语言，而且非常适合面向对象编程，所以用Python编写小游戏上手较快，也相对简单，类似这篇文章介绍的用Python编写的小游戏还有很多，比如Github上这个free-python-games，就包含了贪吃蛇、flappy bird等十多款小游戏，有兴趣的同学可以看看、玩玩。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[some easy algorithm03]]></title>
    <url>%2F2018%2F11%2F25%2Fsome-easy-algorithm03%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&ensp;趁热打铁又做了2019年的网易校招题，结果发现要比2018年的简单不少，题量也从12道降低到7道，而且没有一道动态规划，所以做的比较快，但也还是收获了一些。 2019网易校招题NO.1题目&emsp;&emsp;&ensp;小易有一个古老的游戏机，上面有着经典的游戏俄罗斯方块。因为它比较古老，所以规则和一般的俄罗斯方块不同。荧幕上一共有 n 列，每次都会有一个 1 x 1 的方块随机落下，在同一列中，后落下的方块会叠在先前的方块之上，当一整行方块都被占满时，这一行会被消去，并得到1分。&emsp;&emsp;&ensp;有一天，小易又开了一局游戏，当玩到第 m 个方块落下时他觉得太无聊就关掉了，小易希望你告诉他这局游戏他获得的分数。 样例：输入描述:第一行两个数 n, m第二行 m 个数，c1, c2, … , cm ， ci 表示第 i 个方块落在第几列其中 1 &lt;= n, m &lt;= 1000, 1 &lt;= ci &lt;= n输出描述:小易这局游戏获得的分数输入例子1:3 91 1 2 2 2 3 1 2 3输出例子1:2 源程序123456789#找出所有列中最低的那个即可print("请输入屏幕的列数n和下落的方块数m:")[n,m] = [int(x) for x in input().strip().split(" ")]print("请输入这m个方块下落的列序号:")L = [int(x) for x in input().strip().split(" ")]num_count = []for i in range(1,n+1): num_count.append(L.count(i))print("得分为:",min(num_count)) 运行结果 NO.2题目&emsp;&emsp;&ensp;小易觉得高数课太无聊了，决定睡觉。不过他对课上的一些内容挺感兴趣，所以希望你在老师讲到有趣的部分的时候叫醒他一下。&emsp;&emsp;&ensp;你知道了小易对一堂课每分钟知识点的感兴趣程度，并以分数量化，以及他在这堂课上每分钟是否会睡着，你可以叫醒他一次，这会使得他在接下来的k分钟内保持清醒。&emsp;&emsp;&ensp;你需要选择一种方案最大化小易这堂课听到的知识点分值。 样例：输入描述:第一行 n, k (1 &lt;= n, k &lt;= 105) ，表示这堂课持续多少分钟，以及叫醒小易一次使他能够保持清醒的时间。第二行 n 个数，a1, a2, … , an(1 &lt;= ai &lt;= 104) 表示小易对每分钟知识点的感兴趣评分。第三行 n 个数，t1, t2, … , tn 表示每分钟小易是否清醒, 1表示清醒。输出描述:小易这堂课听到的知识点的最大兴趣值。输入例子1:6 31 3 5 2 5 41 1 0 1 0 0输出例子1:16 源程序123456789101112131415#思路很明确，不过好像超时了……print("请输入这节课的时长n，以及保持清醒的时长k:")[n,k] = [int(x) for x in input().strip().split(" ")]print("请输入对每分钟知识点的感兴趣评分:")interest = [int(x) for x in input().strip().split(" ")]print("请输入每分钟是否会清醒:")is_wakeup = [int(x) for x in input().strip().split(" ")]result = []for i in range(n-k+1): temp = is_wakeup.copy() for j in range(i,i + k): temp[j] = 1 L = [interest[x] * temp[x] for x in range(n)] result.append(sum(L))print("这节课获得的最大知识点数值为:",max(result)) 运行结果 NO.3题目&emsp;&emsp;&ensp;又到了丰收的季节，恰逢小易去牛牛的果园里游玩。牛牛常说他对整个果园的每个地方都了如指掌，小易不太相信，所以他想考考牛牛。&emsp;&emsp;&ensp;在果园里有N堆苹果，每堆苹果的数量为ai，小易希望知道从左往右数第x个苹果是属于哪一堆的。牛牛觉得这个问题太简单，所以希望你来替他回答。 样例：输入描述:第一行一个数n(1 &lt;= n &lt;= 105)。第二行n个数ai(1 &lt;= ai &lt;= 1000)，表示从左往右数第i堆有多少苹果。第三行一个数m(1 &lt;= m &lt;= 105)，表示有m次询问。第四行m个数qi，表示小易希望知道第qi个苹果属于哪一堆。输出描述:m行，第i行输出第qi个苹果属于哪一堆。输入例子:52 7 3 4 931 25 11输出例子:153 源程序1234567891011121314#也很简单，不过这种直接遍历比较的方法有超时了……n = int(input("请输入苹果的堆数:"))print("请输从左往右入每一堆的苹果数目:")A = [int(x) for x in input().strip().split(" ")]m = int(input("请输入询问次数:"))print("请输m个查询的索引值:")Q = [int(x) for x in input().strip().split(" ")]for i in range(1,n): A[i] += A[i-1]for i in range(m): for j in range(n): if Q[i] &lt;= A[j]: print(j+1) break 12345678910111213141516171819202122232425#由于上述方法超时，又换了个看似繁琐实际时间复杂度较低的二分法def get_place(data, left, right, target): i, j = left, right mid = i + (j - i) // 2 while left &lt; right: if data[mid] &gt;= target and data[mid - 1] &lt; target: return mid + 1 elif data[mid] &gt;= target: right = mid - 1 return get_place(data, left, right, target) elif data[mid - 1] &lt; target: left = mid + 1 return get_place(data, left, right, target) return left + 1n = int(input("请输入苹果的堆数:"))print("请输从左往右入每一堆的苹果数目:")A = [int(x) for x in input().strip().split(" ")]m = int(input("请输入询问次数:"))print("请输m个查询的索引值:")Q = [int(x) for x in input().strip().split(" ")]for i in range(1,n): A[i] += A[i-1]for i in range(m): print(get_place(A,0,n-1,Q[i])) 运行结果 NO.4题目&emsp;&emsp;&ensp;又到了周末，小易的房间乱得一团糟。他希望将地上的杂物稍微整理下，使每团杂物看起来都紧凑一些，没有那么乱。&emsp;&emsp;&ensp;地上一共有n团杂物，每团杂物都包含4个物品。第i物品的坐标用(ai,bi)表示，小易每次都可以将它绕着(xi,yi)逆时针旋转90°，这将消耗他的一次移动次数。如果一团杂物的4个点构成了一个面积不为0的正方形，我们说它是紧凑的。&emsp;&emsp;&ensp;因为小易很懒，所以他希望你帮助他计算一下每团杂物最少需要多少步移动能使它变得紧凑。 样例：输入描述:第一行一个数n(1 &lt;= n &lt;= 100)，表示杂物的团数。接下来4n行，每4行表示一团杂物，每行4个数ai, bi，xi, yi, (-10\^4 &lt;= xi, yi, ai, bi &lt;= 10\^4)，表示第i个物品旋转的它本身的坐标和中心点坐标。输出描述:n行，每行1个数，表示最少移动次数。输入例子:41 1 0 0-1 1 0 0-1 1 0 01 -1 0 01 1 0 0-2 1 0 0-1 1 0 01 -1 0 01 1 0 0-1 1 0 0-1 1 0 0-1 1 0 02 2 0 1-1 0 0 -23 0 0 -2-1 1 -2 0输出例子:1-133例子说明:对于第一团杂物，我们可以旋转第二个或者第三个物品1次。 源程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748'''这题虽然比较烦，但是思路还是很明确的，用到一个旋转函数和一个判断正方形的函数，接着就是无脑地遍历比较了，这题时间居然没有超……'''#逆时针旋转90°def rotate(point): #print(point) x = point[2] - (point[1] - point[3]) y = point[3] - (point[2] - point[0]) return [x, y]#判断是否是正方形def is_square(a, b, c, d): x = float(a[0] + b[0] + c[0] + d[0]) / 4 y = float(a[1] + b[1] + c[1] + d[1]) / 4 newpoint = [rotate(a+[x,y]), rotate(b+[x,y]), rotate(c+[x,y]), rotate(d+[x,y])] newpoint.sort() oldpoint = [a,b,c,d] oldpoint.sort() if newpoint == oldpoint and [x,y] != a: #如果四个点逆时针旋转90°还是这四个坐标，则是正方形，注意防止四点重合 return True return Falsen = int(input("请输入杂物的团数:"))result = []print("请输入每个物品的坐标ai, bi，以及旋转中心的坐标xi, yi:")for i in range(n): data = [] best_t = float('inf') #用来记录最少操作次数 for j in range(4): a, b, x, y = list(map(int, input().split())) temp = [[a, b]] for k in range(3): temp.append(rotate(temp[-1] + [x, y])) #记录每个点旋转1，2，3次后的坐标 data.append(temp) #print(data) # 遍历所有的可能性 for i in range(4): for j in range(4): for k in range(4): for m in range(4): if is_square(data[0][i], data[1][j], data[2][k], data[3][m]): best_t = min(best_t, i + j + k + m) if best_t == float('inf'): #如果怎么旋转都不能构成正方形 result.append(-1) else: result.append(best_t)for i in range(n): print("第"+str(i+1)+"堆最少需要移动"+str(result[i])+"次") 运行结果 NO.5题目&emsp;&emsp;&ensp;今天上课，老师教了小易怎么计算加法和乘法，乘法的优先级大于加法，但是如果一个运算加了括号，那么它的优先级是最高的。例如：1+2*3=71*(2+3)=51*2*3=6(1+2)*3=9&emsp;&emsp;&ensp;现在小易希望你帮他计算给定3个数a，b，c，在它们中间添加”+”， “*“， “(“， “)”符号，能够获得的最大值。 样例：输入描述:一行三个数a，b，c。(1 &lt;= a, b, c &lt;= 10)输出描述:能够获得的最大值。输入例子:1 2 3输出例子:9 源程序1234567891011#这题可能是送分题……把6种情况都考虑即可print("请输入3个数:")[a,b,c] = [int(x) for x in input().strip().split(" ")]L = []L.append(a+b+c)L.append(a*b*c)L.append((a+b)*c)L.append(a*(b+c))L.append(a*b+c)L.append(a+b*c)print("能获得的最大值为:",max(L)) 运行结果 NO.6题目&emsp;&emsp;&ensp;小易有一些立方体，每个立方体的边长为1，他用这些立方体搭了一些塔。&emsp;&emsp;&ensp;现在小易定义：这些塔的不稳定值为它们之中最高的塔与最低的塔的高度差。小易想让这些塔尽量稳定，所以他进行了如下操作：每次从某座塔上取下一块立方体，并把它放到另一座塔上。注意，小易不会把立方体放到它原本的那座塔上，因为他认为这样毫无意义。&emsp;&emsp;&ensp;现在小易想要知道，他进行了不超过k次操作之后，不稳定值最小是多少。 样例：输入描述:第一行两个数n,k (1 &lt;= n &lt;= 100, 0 &lt;= k &lt;= 1000)表示塔的数量以及最多操作的次数。第二行n个数，ai(1 &lt;= ai &lt;= 104)表示第i座塔的初始高度。输出描述:第一行两个数s, m，表示最小的不稳定值和操作次数。(m &lt;= k)接下来m行，每行两个数x,y表示从第x座塔上取下一块立方体放到第y座塔上。输入例子:3 25 8 5输出例子:0 22 12 3 源程序1234567891011121314151617#这题的思路也比较明确，注意到停止条件当最高高度和最低高度的差小于等于1时就很容易做了。print("请输入塔的数量n和最多操作次数k:")[n,k] = [int(x) for x in input().strip().split(" ")]print("请输入每个塔的初始高度:")L = [int(x) for x in input().strip().split(" ")]result = []for i in range(k): diff = max(L) - min(L) if diff &lt;= 1: break else: result.append([L.index(max(L)) + 1, L.index(min(L)) + 1]) L[L.index(max(L))] -= 1 L[L.index(min(L))] += 1print(str(max(L) - min(L)) + ' ' + str(len(result)))for i in range(len(result)): print(str(result[i][0]) + ' ' + str(result[i][1])) 运行结果 NO.7题目&emsp;&emsp;&ensp;小易在学校中学习了关于字符串的理论, 于是他基于此完成了一个字典的项目。&emsp;&emsp;&ensp;小易的这个字典很奇特, 字典内的每个单词都包含n个’a’和m个’z’, 并且所有单词按照字典序排列。小易现在希望你能帮他找出第k个单词是什么。 样例：输入描述:输入包括一行三个整数n, m, k(1 &lt;= n, m &lt;= 100, 1 &lt;= k &lt;= 109), 以空格分割。输出描述:输出第k个字典中的字符串，如果无解，输出-1。输入例子:2 2 6输出例子:zzaa例子说明:字典中的字符串依次为aazz azaz azza zaaz zaza zzaa 源程序123456789101112131415161718#这题实际上是一个全排列问题。#自己想没有头绪，主要是对全排列的基本概念不熟，然后网上一搜有很多解释，结果超时了……def full_permutation(position,end,arr,result=set()): if position == end: result.add("".join(arr)) else: for idx in range(position,end): arr[idx], arr[position] = arr[position], arr[idx] #position位置的元素与本身以及后面的元素进行交换，以确定position位置的元素 full_permutation(position + 1, end, arr, result) #确定了position位置的元素后，再确定后面位置的元素 arr[idx], arr[position] = arr[position], arr[idx] #把数组恢复成原来的样子 return result print("请输入字母a的个数n，字母z的个数m和查询索引值k:")[n, m, k] = [int(x) for x in input().strip().split(" ")]arr = ['a'] * n + ['z'] * mL = list(full_permutation(0,len(arr),arr))L.sort()print("查询的字符串为:",L[k-1]) 运行结果 后记&emsp;&emsp;&ensp;几乎每道题的思路都很明确，但往往最容易想到的方法，时间复杂度要比较高，所以还需改进算法，或者采用其他更优的算法，这也应当是以后需要注意的方面。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[some easy algorithm02]]></title>
    <url>%2F2018%2F11%2F23%2Fsome-easy-algorithm02%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&ensp;最近又花了点时间做了2018年网易的春季校招题，和上次做的华为校招相比，网易的题目难度要稍稍高出一些，而且题量比较大，一共有12题，限时3小时？太可怕了🌚……当然还是有不少题比较容易上手的，只是像动态规划这类题有些多，对于我这种编程经验少的小菜鸡，还是很头疼的🙃。多加练习应该会有所进步吧！&emsp;&emsp;&ensp;这12题我都是用Python实现的，并且在牛客网进行了测试，通过率没达到100%的都是因为超出时间限制了🌚……应该是我的方法不是最佳导致的，但也是一种解题思路吧，话不多说，放代码😁。 2018网易校招题NO.1题目&emsp;&emsp;&ensp;一种双核CPU的两个核能够同时的处理任务，现在有n个已知数据量的任务需要交给CPU处理，假设已知CPU的每个核1秒可以处理1kb，每个核同时只能处理一项任务。n个任务可以按照任意顺序放入CPU进行处理，现在需要设计一个方案让CPU处理完这批任务所需的时间最少，求这个最小的时间。 样例：输入包括两行：第一行为整数n(1 ≤ n ≤ 50)。第二行为n个整数length[i],(1024 ≤ length[i] ≤ 4194304)，表示每个任务的长度为length[i]kb，每个数均为1024的倍数。输出一个整数，表示最少需要处理的时间。输入样例：53072 3072 7168 3072 1024输出样例:9216 源代码1234567891011121314151617#背包问题，即把数组分成两部分，使这两部分的和相差最小，也就是和小的那一部分的和尽可能接近于总合的一半def sum_time(idx,V,L): if idx == 0 : return L[0] else: if V&gt;L[idx]: return max(sum_time(idx-1,V,L),sum_time(idx-1,V-L[idx],L)+L[idx]) #动态规划，sum_time(idx,V,L)是指前idx个物品装入容量为V的背包中所可以获得的最大值 #sum_time(idx-1,V,L)表示第idx个物品不装入背包的情况，sum_time(idx-1,V-L[idx],L)+L[idx]表示第idx个物品装入背包的情况 else: return sum_time(idx-1,V,L)n = int(input("请输入任务个数[1,50]:"))print("请输入任务量[1024,4194304]，且是1024的倍数:")L = [int(x) for x in input().strip().split(' ')]L.sort() #排序，防止L[0]&gt;sum/2V = sum(L)/2 #计算背包容量print("最少耗时为:",sum(L) - sum_time(len(L)-1,V,L)) 1234567891011121314'''法二，这是借鉴他人的方法，比我自己写的确实简单，但是我没有完全看懂他的意思……比如用提供的样例测试，在循环过后输出h，会得到12288，这其实是4个3078相加得到的结果，在实际分组中不会出现，所以我也不能确定他的方法对不对……不过他倒是能通过牛客网的测试🌚。'''n=int(input())arr = [int(x) for x in input().strip().split(' ')]h=set(arr)for i in arr: for j in list(h): h.add(i+j)#print(h)h = [i for i in h if i&gt;=sum(arr)/2]print(min(h)) 运行结果 NO.2题目&emsp;&emsp;&ensp;小易走在市区的街道上准备找朋友聚会，突然服务器发来警报,小易需要立即回公司修复这个紧急bug。&emsp;&emsp;&ensp;假设市区是一个无限大的区域，每条街道假设坐标是(X，Y)，小易当前在(0，0)街道，办公室在(gx,gy)街道上。小易周围有多个出租车打车点，小易赶去办公室有两种选择，一种就是走路去公司，另外一种就是走到一个出租车打车点，然后从打车点的位置坐出租车去公司。&emsp;&emsp;&ensp;每次移动到相邻的街道(横向或者纵向)走路将会花费walkTime时间，打车将花费taxiTime时间。小易需要尽快赶到公司去，现在小易想知道他最快需要花费多少时间去公司。 样例：输入数据包括五行:第一行为周围出租车打车点的个数n(1 ≤ n ≤ 50)。第二行为每个出租车打车点的横坐标tX[i],(-10000 ≤ tX[i] ≤ 10000)。第三行为每个出租车打车点的纵坐标tY[i], (-10000 ≤ tY[i] ≤ 10000)。第四行为办公室坐标gx,gy,(-10000 ≤ gx,gy ≤ 10000),以空格分隔。第五行为走路时间walkTime,(1 ≤ walkTime ≤ 1000)和taxiTime,(1 ≤ taxiTime ≤ 1000),以空格分隔。输出一个整数表示，小易最快能赶到办公室的时间。输入样例：2-2 -20 -2-4 -215 3输出样例：42 源代码12345678910111213141516#很简单，没啥说的n = int(input("请输入打车点数:"))print("请输入打车点的横坐标:")tX = [int(x) for x in input().strip().split(' ')]print("请输入打车点的纵坐标:")tY = [int(y) for y in input().strip().split(' ')]print("请输入办公室坐标:")[gx,gy] = [int(i) for i in input().strip().split(' ')]print("请输入走路时间和打车时间:")[walkTime,taxiTime]= [int(i) for i in input().strip().split(' ')]Walktime = (abs(gx) + abs(gy)) * walkTime #走路去公司花的时间Dis1 = [abs(tX[i]) + abs(tY[i]) for i in range(len(tX))] #人距打车点的距离Dis2 = [abs(tX[i] - gx) + abs(tY[i] - gy) for i in range(len(tX))] #办公室距打车点的距离Taxitime = [(Dis1[i] * walkTime + Dis2[i] * taxiTime) for i in range(len(tX))] #打车去公司花的时间mintime = min(Walktime,min(Taxitime))print("最快赶到办公室的时间为:",mintime) 运行结果 NO.3题目&emsp;&emsp;&ensp;在幼儿园有n个小朋友排列为一个队伍，从左到右一个挨着一个编号为(0~n-1)。其中有一些是男生，有一些是女生，男生用’B’表示，女生用’G’表示。&emsp;&emsp;&ensp;小朋友们都很顽皮，当一个男生挨着的是女生的时候就会发生矛盾。作为幼儿园的老师，你需要让男生挨着女生或者女生挨着男生的情况最少。你只能在原队形上进行调整，每次调整只能让相邻的两个小朋友交换位置。&emsp;&emsp;&ensp;现在需要尽快完成队伍调整，你需要计算出最少需要调整多少次可以让上述情况最少。&emsp;&emsp;&ensp;例如：GGBBG -&gt; GGBGB -&gt; GGGBB这样就使之前的两处男女相邻变为一处相邻，需要调整队形2次。 样例：输入数据包括一个长度为n且只包含G和B的字符串，n不超过50。输出一个整数，表示最少需要的调整队伍的次数。输入样例：GGBBG输出样例：2 源代码12345678910111213141516#从最终的情况考虑，即G全在左边或B全在左边。mystr = input("请输入一个长度小于50的字符串：")sG = 0sB = 0sumG = 0sumB = 0for s in mystr: if s == 'G': sumG += mystr.index(s) - sG mystr = mystr.replace('G', 'X', 1) sG += 1 elif s =='B': sumB += mystr.index(s) - sB mystr = mystr.replace('B', 'X', 1) sB += 1print("最少调整次数为:",min(sumB,sumG)) 运行结果 NO.4题目&emsp;&emsp;&ensp;有一个长度为n序列，小易想移除掉里面的重复元素，但是小易想是对于每种元素保留最后出现的那个。小易遇到了困难,希望你来帮助他。 样例：输入包括两行：第一行为序列长度n(1 ≤ n ≤ 50)第二行为n个数sequence[i],(1 ≤ sequence[i] ≤ 1000)，以空格分隔。输出消除重复元素之后的序列，以空格分隔，行末无空格。输入样例：9100 100 100 99 99 99 100 100 100输出样例：99 100 源代码123456789101112131415#emmm，也没啥说的，利用删除添加即可。n = int(input("请输入元素个数:"))print("请输入元素序列:")L = [int(i) for i in input().strip().split(' ')]a = []for s in L: if s in a: a.remove(s) a.append(s) else: a.append(s)print("去除重复元素后的序列为:")for i in range(len(a)-1): print(a[i],end = ' ')print(a[-1]) 运行结果 NO.5题目&emsp;&emsp;&ensp;小易拥有一个拥有魔力的手环，上面有n个数字(构成一个环),当这个魔力手环每次使用魔力的时候就会发生一种奇特的变化：每个数字会变成自己跟后面一个数字的和(最后一个数字的后面一个数字是第一个),一旦某个位置的数字大于等于100就马上对100取模(比如某个位置变为103,就会自动变为3)。&emsp;&emsp;&ensp;现在给出这个魔力手环的构成，请你计算出使用k次魔力之后魔力手环的状态。 样例：输入数据包括两行：第一行为两个整数n (2 ≤ n ≤ 50)和k (1 ≤ k ≤ 2000000000),以空格分隔。第二行为魔力手环初始的n个数，以空格分隔，范围都在0至99。输出魔力手环使用k次之后的状态，以空格分隔，行末无空格。输入样例：3 21 2 3输出样例：8 9 7 源代码123456789101112131415#这里要注意直接赋值、浅拷贝和深拷贝的区别。print("请输入数字个数n和使用次数k:")[n,k] = [int(i) for i in input().strip().split(' ')]print("请输入初始的n个数:")L = [int(i) for i in input().strip().split(' ')]L0 = L.copy() #浅拷贝，注意列表不能直接简单的赋值！！！for i in range(k): for j in range(n-1): L0[j] = (L[j] + L[j+1]) % 100 L0[-1] = (L[-1] + L[0]) % 100 L = L0.copy()print("使用后手环上的数字为:")for i in range(len(L)-1): print(L[i],end = ' ')print(L[-1]) 运行结果 NO.6题目&emsp;&emsp;&ensp;现在有n位工程师和6项工作(编号为0至5)，现在给出每个人能够胜任的工作序号表(用一个字符串表示，比如：045，表示某位工程师能够胜任0号，4号，5号工作)。&emsp;&emsp;&ensp;现在需要进行工作安排，每位工程师只能被安排到自己能够胜任的工作当中去，两位工程师不能安排到同一项工作当中去。&emsp;&emsp;&ensp;如果两种工作安排中有一个人被安排在的工作序号不一样就被视为不同的工作安排，现在需要计算出有多少种不同工作安排计划。 样例：输入数据有n+1行：第一行为工程师人数n(1 ≤ n ≤ 6)。接下来的n行，每行一个字符串表示第i(1 ≤ i ≤ n)个人能够胜任的工作(字符串不一定等长的)。输出一个整数，表示有多少种不同的工作安排方案。输入样例：6012345012345012345012345012345012345输出样例：720 源代码12345678910111213141516171819#题目有两点没有交代清楚，非常坑:#1、所有工程师都必须有事可做，且一个人只能做一项工程，而不能分饰两角#2、不必所有事都要做。def workways(n,work,res): ways = 0 for ws in work[n]: # 遍历第n个工程师能做的工作 if ws not in res: # 如果该工作没有被安排 if n == 0: ways += 1 #如果最后一个工程师还能够安排工作，则数量 +1. else: ways += workways(n-1,work,res+[ws]) #将工作ws安排后，剩下n-1个工程师能分配的方法 return waysn = int(input("请输入工程师人数:"))L =[]print("请输入每个人能够胜任的工作序号:")for i in range(n): L.append(input(""))print("一共有",workways(n-1,L,[]),"种工作安排") 运行结果 NO.7题目&emsp;&emsp;&ensp;小易最近在数学课上学习到了集合的概念,集合有三个特征：1.确定性 2.互异性 3.无序性.小易的老师给了小易这样一个集合： S = \{ p/q | w ≤ p ≤ x, y ≤ q ≤ z \}&emsp;&emsp;&ensp;需要根据给定的w，x，y，z,求出集合中一共有多少个元素。小易才学习了集合还解决不了这个复杂的问题,需要你来帮助他。 样例：输入包括一行：一共4个整数分别是w(1 ≤ w ≤ x)，x(1 ≤ x ≤ 100)，y(1 ≤ y ≤ z)，z(1 ≤ z ≤ 100)，以空格分隔。输出集合中元素的个数。输入样例：1 10 1 1输出样例：10 源代码12345678#很简单，注意集合的使用。print("请输入4个整数w,x,y,z:")[w,x,y,z] = [int(i) for i in input("").strip().split(' ')]s = set()for p in range(w,x+1): for q in range(y,z+1): s.add(float(p)/q)print("集合中元素个数为:",len(s)) 运行结果 NO.8题目&emsp;&emsp;&ensp;常规的表达式求值，我们都会根据计算的优先级来计算。比如*/的优先级就高于+-。&emsp;&emsp;&ensp;但是小易所生活的世界的表达式规则很简单，从左往右依次计算即可，而且小易所在的世界没有除法，意味着表达式中没有/，只有(+, - 和 *)。&emsp;&emsp;&ensp;现在给出一个表达式，需要你帮忙计算出小易所在的世界这个表达式的值为多少。 样例：输入为一行字符串，即一个表达式。其中运算符只有-,+,*。参与计算的数字只有0~9。保证表达式都是合法的，排列规则如样例所示。输出一个数，即表达式的值。输入样例：3+5*7输出样例：56 源代码123456789101112#思路也很明确，利用参与计算的数字只有0~9的条件。mystr = input("请输入一个表达式:")result = 0L = list(mystr)for i in range(len(L)): if L[i] == '+': L[i + 1] = str(int(L[i - 1]) + int(L[i + 1])) elif L[i] == '-': L[i + 1] = str(int(L[i - 1]) - int(L[i + 1])) elif L[i] == '*': L[i + 1] = str(int(L[i - 1]) * int(L[i + 1]))print("运算结果为:",int(L[-1])) 运行结果 NO.9题目&emsp;&emsp;&ensp;小易有一块n*n的棋盘，棋盘的每一个格子都为黑色或者白色，小易现在要用他喜欢的红色去涂画棋盘。&emsp;&emsp;&ensp;小易会找出棋盘中某一列中拥有相同颜色的最大的区域去涂画，帮助小易算算他会涂画多少个棋格。 样例：输入数据包括n+1行：第一行为一个整数n(1 ≤ n ≤ 50),即棋盘的大小。接下来的n行每行一个字符串表示第i行棋盘的颜色，’W’表示白色，’B’表示黑色。输出小易会涂画的区域大小。输入样例：3BWWBBBBWB输出样例：3 源代码123456789101112131415161718192021222324252627#这题我写的比较烦了，开始没理解题目的要求，原来是要求连续的区域。#后来懒得换方法就直接在原来代码上改了。import re#输入n = int(input("请输入棋盘的大小n:"))print("输入每一行的颜色:")L = []for i in range(n): L.append(input())#行变成列，相当于转置L1 = []for i in range(n): L0 = [] for j in range(n): L0.append(L[j][i]) L1.append("".join(L0))#计算各列最大连续个数 B = []W = []for i in range(len(L1)): tmpB = re.findall('B+',L1[i]) tmpW = re.findall('W+',L1[i]) tmpB.append('B') #防止出现tmpB为空的现状，就不能计算len了， tmpW.append('W') #这样的话只会把长度增加1，并不会影响最终的结果 B.append(max(len(s) for s in tmpB)) W.append(max(len(s) for s in tmpW))print("最终涂画区域大小为:",max(max(B),max(W))) 12345678910111213141516171819#法二，由于我的方法比较繁琐，就再贴上别人的代码吧#该方法很常规又比较机智……巧妙利用了列表的-1索引值。我怎么就想了上面那个这么繁琐的方法🙃。import sysline = sys.stdin.readline().strip()num = int(line)arr = []for i in range(num): arr.append(sys.stdin.readline().strip())print(arr)result = []for i in range(num): B_count = [1] for j in range(0,num-1): if arr[j][i] == arr[j+1][i]: B_count[-1] += 1 else: B_count.append(1) result.append(max(B_count))print(max(result)) 运行结果 NO.10题目&emsp;&emsp;&ensp;小易参与了一个记单词的小游戏。游戏开始系统提供了m个不同的单词，小易记忆一段时间之后需要在纸上写出他记住的单词。&emsp;&emsp;&ensp;小易一共写出了n个他能记住的单词，如果小易写出的单词是在系统提供的，将获得这个单词长度的平方的分数。注意小易写出的单词可能重复，但是对于每个正确的单词只能计分一次。 样例：输入数据包括三行：第一行为两个整数n(1 ≤ n ≤ 50)和m(1 ≤ m ≤ 50)。以空格分隔第二行为n个字符串，表示小易能记住的单词，以空格分隔，每个单词的长度小于等于50。第三行为m个字符串，系统提供的单词，以空格分隔，每个单词的长度小于等于50。输出一个整数表示小易能获得的分数输入样例：3 4apple orange strawberrystrawberry orange grapefruit watermelon输出样例：136 源代码12345678910111213#比较简单，利用集合……不过这也能超时？print("请输入能记住的单词数n和系统提供的单词数m:")[n,m] = [int(x) for x in input().strip().split(" ")]print("请输入能记住的单词:")L = [x for x in input().strip().split(" ")]print("请输入系统提供的单词:")L0 = [x for x in input().strip().split(" ")]remset = set(L)scores = 0for words in remset: if words in L0: scores += len(words)*len(words)print("最终得分为:",scores) 运行结果 NO.11题目&emsp;&emsp;&ensp;小易有n块砖块，每一块砖块有一个高度。小易希望利用这些砖块堆砌两座相同高度的塔。&emsp;&emsp;&ensp;为了让问题简单，砖块堆砌就是简单的高度相加，某一块砖只能使用在一座塔中一次。小易现在让能够堆砌出来的两座塔的高度尽量高，小易能否完成呢。 样例：输入包括两行：第一行为整数n(1 ≤ n ≤ 50)，即一共有n块砖块。第二行为n个整数，表示每一块砖块的高度height[i],(1 ≤ height[i] ≤ 500000)。如果小易能堆砌出两座高度相同的塔，输出最高能拼凑的高度，如果不能则输出-1。保证答案不大于500000。输入样例：32 3 5输出样例：5 源代码123456789101112131415161718192021222324252627'''动态规划，tower(idx,diff)表示用i个砖块堆积，使两个塔相差diff，比较矮的搭的高度。寻找idx和idx-1的关系，可以分四种情况，取最大值1、丢弃第i块砖tower(idx - 1, diff, L)2、第i块砖放低塔，低塔仍是低塔tower(idx - 1, diff + L[idx-1], L) + L[idx-1]3、第i块砖放低塔，低塔变高塔tower(idx - 1, L[idx-1] - diff, L) + L[idx-1] - diff)4、第i块砖放高塔上tower(idx - 1, diff - L[idx-1], L)'''def tower(idx,diff,L): if idx == 0 and diff == 0: return 0 elif idx == 0 and diff &gt;0: return float('-inf') elif idx &gt; 0: if diff &gt; L[idx-1]: return max(tower(idx - 1, diff, L), tower(idx - 1, diff + L[idx-1], L) + L[idx-1], tower(idx - 1, diff - L[idx-1], L)) elif diff &lt;= L[idx-1]: return max(tower(idx - 1, diff, L), tower(idx - 1, diff + L[idx-1], L) + L[idx-1], tower(idx - 1, L[idx-1] - diff, L) + L[idx-1] - diff)n = int(input("请输入砖块数:"))print("请输入每一块砖块的高度:")L = [int(x) for x in input().strip().split(" ")]if tower(len(L),0,L) &lt;= 0: print(-1)else: print("最高相同高度为:",tower(len(L),0,L)) 运行结果 NO.12题目&emsp;&emsp;&ensp;易老师购买了一盒饼干，盒子中一共有k块饼干，但是数字k有些数位变得模糊了，看不清楚数字具体是多少了。&emsp;&emsp;&ensp;易老师需要你帮忙把这k块饼干平分给n个小朋友，易老师保证这盒饼干能平分给n个小朋友。现在你需要计算出k有多少种可能的数值 。 样例：输入包括两行：第一行为盒子上的数值k，模糊的数位用X表示，长度小于18(可能有多个模糊的数位)。第二行为小朋友的人数n。输出k可能的数值种数，保证至少为1。输入样例：9999999999999X3输出样例：4 源代码123456789101112131415161718192021'''没错，又是动态规划🌚……但这里用的不是函数递归，我用递归写了好久最后还是放弃了。主要利用不同位数产生余数的关系。比如已经知道123%4的余数是3，怎么计算1234%4呢？（3*10+4）%4=2，这就计算出来了。'''k = input("请输入饼干数目:")n = int(input("请输入小朋友人数:"))rem = [1] + [0] * (n-1)for s in k: temp = [0] * n if s != 'X': for i in range(n): temp[ (i * 10 + int(s)) % n ] += rem[i] else: for s in range(10): for i in range(n): temp[(i * 10 + s) % n] += rem[i] rem = temp.copy()print("共有",rem[0],"种可能") 运行结果 后记&emsp;&emsp;&ensp;终于刷完了这12题，一路坎坷，还要加倍努力才行。其实这12题主要就是1、6、11、12这4道涉及了动态规划，比较锻炼脑力、考验算法的选择，其他题都还好。不多说了，搬砖去……]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[some easy algorithm01]]></title>
    <url>%2F2018%2F11%2F21%2Fsome-easy-algorithm01%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&ensp;今天刷了几道华为的校招题，网上大都是用C++实现的，而我采用了更为方便的Python，对于我这种很少编程的人来说，还是有些收获的，于是打算把这些题整理一下。 华为校招题NO.1题目输入一串字符串，统计字符串中各字符出现的次数，并将其按照ASCII码递增的顺序输出，输出要求每种字符都先一个一个输出。 样例：输入:eeefgghh输出:efgheghe 源代码123456789101112131415161718192021222324#统计字符个数mystr = input("请输入一串字符:")strnum = &#123;&#125;L0 = list(mystr)L = []#统计每个字符的个数for i in mystr: strnum[i] = mystr.count(i)print(strnum)#将字符串排序L0.sort()mystr = "".join(L0)#按要求进行重排length = len(mystr)while(length&gt;0): for x in strnum.keys(): if strnum[x] &gt; 0: L.append(x) strnum[x] -= 1 length -= 1#列表转字符串result = "".join(L)print(result) 运行结果 NO.2题目给出一个字符串，将重复的字符去除，仅保留第一次出现的字符，且保持去重后的字符在原字符串中的顺序不变。 样例：输入:aabcdfffea输出:abcdfe 源代码1234567#给出一个字符串，将重复的字符去除，仅保留第一次出现的字符，且保持去重后的字符在原字符串中的顺序不变。mystr = input("请输入一串字符:")strdict = &#123;&#125;for i in mystr: strdict[i] = mystr.count(i)result = "".join(strdict.keys())print(result) 运行结果 NO.3题目举行一场8小时的聚会，12：00-20：00，让来访客人事先填好到达的时间和离开的时间，为了掌握聚会期间座位的数目，需要先估计不同时间的最大客人数量。1、以整点计算，比如“12，18”表示12点后13点前到，17点后18点前离开2、按小时区间统计客人数量，需统计[12,13).[13.14)…[19,,20)共8个时间段的客人数3、假设最大邀请100人 样例见运行结果（注意输入的逗号是英文） 源代码12345678910111213141516171819persondict = &#123;'[12,13)':0,'[13,14)':0,'[14,15)':0,'[15,16)':0,'[16,17)':0,'[17,18)':0,'[18,19)':0,'[19,20)':0&#125;timetable = ['[12,13)','[13,14)','[14,15)','[15,16)','[16,17)','[17,18)','[18,19)','[19,20)']mystr = input("请输入到达和离开时间:")[arrive,leave] = mystr.split(',')for i in range(int(arrive)-12,int(leave)-12): persondict[timetable[i]] += 1ans = input("是否还有来宾？[y/n]:")person = 1while(person&lt;100): if ans == 'y': person += 1 mystr = input("请输入到达和离开时间:") [arrive, leave] = mystr.split(',') for i in range(int(arrive) - 12, int(leave) - 12): persondict[timetable[i]] += 1 ans = input("是否还有来宾？[y/n]:") else: breakprint(persondict) 运行结果 NO.4题目请一个在字符串中找出连续最长的数字串，并把这个串的长度返回；如果存在长度相同的连续数字串，返回最后一个连续数字串；如果没有数字，则返回空字符串（“”）而不是NULL 样例见运行结果 源代码123456789101112131415import remystr = input("请输入一个字符串:")L = re.findall('\d+',mystr) #提取所有连续的数字串if(len(L) == 0): maxnum ="\"""\"" #如果没有数字，则返回空字符串（“”） maxlen = 0else: maxnum = L[0] maxlen = len(L[0]) for num in L: if len(num) &gt;= maxlen: maxnum = num maxlen = len(num)print("最长的数字串为:",maxnum)print("长度为:",maxlen) 运行结果 NO.5题目输入两个长整数,输出相乘后的结果 样例见运行结果 源代码1234567891011121314151617181920212223242526#输入两个长整数,输出相乘后的结果num1 = int(input("请输入第一个数:"))num2 = int(input("请输入第二个数:"))#判断结果的正负if ((num1&gt;0) and (num2&gt;0)) or ((num1&lt;0) and (num2&lt;0)): flag = 1else: flag = -1#转为列表处理L1 = list(str(abs(num1)))L2 = list(str(abs(num2)))L1.reverse()L2.reverse()L = []#乘法运算的步骤q = 1for i in L1: s = 0 p = 1 for j in L2: s += int(i)*int(j)*p*q p *= 10 q *= 10 L.append(s)result = sum(L)*flagprint(result) 运行结果 NO.6题目按要求分解字符串，输入两个数M，N；M代表输入的M串字符串，N代表输出的每串字符串的位数，不够补0。 样例输入：2,8， “abc” ,“123456789“,输出：“abc00000”,“12345678“,”90000000” 源代码12345678910111213141516#按要求分解字符串，输入两个数M，N；M代表输入的M串字符串，N代表输出的每串字符串的位数，不够补0。# 例如：输入2,8， “abc” ,“123456789“,则输出为“abc00000”,“12345678“，”90000000”M = int(input("请输入字符串的数目："))N = int(input("请输入每个字符串的长度："))for i in range(M): mystr = input("请输入字符串：") if len(mystr)&gt;N: if len(mystr)%N != 0: mystr = mystr.ljust((int(len(mystr)/N)+1)*N,'0') #result = re.findall(r'.&#123;3&#125;',mystr) result =[] for i in range (int(len(mystr)/N)): result.append(mystr[i*N:(i+1)*N]) else: result = mystr.ljust(N,'0') print("第"+str(i+1)+"个字符串操作后的结果为：",result) 运行结果 NO.7题目输入一个正整数X，在下面的等式左边的数字之间添加+号或者-号，使得等式成立。1 2 3 4 5 6 7 8 9 = X比如：12-34+5-67+89 = 5 1+23+4-5+6-7-8-9 = 5 样例输入：5输出：21 源代码123456789101112131415161718192021222324252627输入一个正整数X，在下面的等式左边的数字之间添加+号或者-号，使得等式成立。 1 2 3 4 5 6 7 8 9 = X 比如： 12-34+5-67+89 = 5 1+23+4-5+6-7-8-9 = 5 请编写程序，统计满足输入整数的所有整数个数。 输入： 正整数，等式右边的数字 输出： 使该等式成立的个数 样例输入：5 样例输出：21思路：动态规划，当前种类=符号位加号的种类+符号为减号的种类+没有符号的种类 ways(before_num,behind_number,temp_result,ex,L)= ways(before_num-1,L[before_num-1],temp_result - behind_number,1,L) + ways(before_num-1,L[before_num-1],temp_result + behind_number,1,L) + ways(before_num-1,L[before_num-1]*pow(10,ex)+behind_number,temp_result,ex+1,L); before_num: 需要判定的符号前面的数字的个数，初始为8 behind_number: 需要判定的符号后面的数字，初始为9 temp_result:方程右边的结果 ex:阶乘数，因为符号有三种可能，加号，减号，或者没有，如果没有，那么ex就用于计算当前值 L:测试列表 def ways(before_num,behind_number,temp_result,ex,L): if before_num == 0: if behind_number == temp_result: #如果最后等式两边相等，方法+1 return 1 else: return 0 else: return ways(before_num-1,L[before_num-1],temp_result - behind_number,1,L) + ways(before_num-1,L[before_num-1],temp_result + behind_number,1,L) + ways(before_num-1,L[before_num-1]*pow(10,ex)+behind_number,temp_result,ex+1,L)X = int(input("请输入一个正整数："))L = list(range(1, 10))print("一共有",ways(len(L)-1,L[-1],X,1,L),"种方法") 运行结果 NO.8题目给定一个字符串，里边可能包含“()”、“[]”、“{}”三种括号，请编写程序检查该字符串中的括号是否成对出现，且嵌套关系正确。true:若括号成对出现且嵌套关系正确，或该字符串中无括号字符；false:若未正确使用括号字符。 样例见运行结果（注意是英文输入） 源代码12345678910111213141516171819202122232425262728import sysmystr = input("请输入一个字符串：")L = ['1']for i in range(len(mystr)): if mystr[i] == ('(' or '[' or '&#123;'): L.append(mystr[i]) elif mystr[i] == ')': if L[-1] == '(': L.pop() else: print('False') sys.exit() elif mystr[i] == ']': if L[-1] == '[': L.pop() else: print('False') sys.exit() elif mystr[i] == '&#125;': if L[-1] == '&#123;': L.pop() else: print('False') sys.exit()if L == ['1']: print('True')else: print('False') 运行结果 NO.9题目给定一个M行N列的矩阵（M*N个格子），每个格子中放着一定数量的苹果。你从左上角的各自开始，只能向下或者向右走，目的地是右下角的格子。每走过一个格子，就把格子上的苹果都收集起来。求你最多能收集到多少苹果。注意：当经过一个格子时，需要一次性把格子里的平安果都拿走。限制条件：1&lt;N,M&lt;=50；每个格子里的苹果数量是0到1000（包含0和1000）.输入包含两部分： 第一部分矩阵的行和列：M, N 接下来输入M行，N列的苹果数量 样例见运行结果 源代码1234567891011121314151617181920212223'''思路：当前位置能够获得的最大苹果数=max(从上面走能够获得最大苹果+从左边走能获得最大苹果）'''def sum_apple(m,n,num): if m==0 and n==0: return num[0][0] elif m==0 and n&gt;0: return num[m][n] + sum_apple(m,n - 1,num) elif m&gt;0 and n==0: return num[m][n] + sum_apple(m - 1,n,num) else: return num[m][n] + max(sum_apple(m,n-1,num),sum_apple(m - 1,n, num))M = int(input("请输入矩阵的行数[0,50]："))N = int(input("请输入矩阵的列数[0,50]："))print("请输入每个格子的苹果数[0,1000]")num = []for i in range(M): temp = [] for j in range(N): temp.append(int(input())) num.append(temp)print("可以获得的最大苹果数是：",sum_apple(M-1,N-1,num)) 运行结果 后记&emsp;&emsp;&ensp;今天就写这么多吧，还是学到了不少东西的。比如正则表达式中{}里面的次数要求是常量，而Python没有定义const类，需要自己定义或另谋出路；对于动态规划问题也有了更深刻的理解，主要是运用递归，可以将复杂的问题简单化；对字符串和列表的操作更加熟练了，并知道了一些以前没有用过的函数用法，果然还是得多练呐😁。&emsp;&emsp;&ensp;虽然很多题目可能都没用到最简洁的算法，但能力还是会一点点提高的，继续努力吧！😉]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thousand separator]]></title>
    <url>%2F2018%2F11%2F19%2Fthousand-separator%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&ensp;偶然看到一个简单的算法题，是一个千位分割的问题，就是比如输入12345678，输出12,345,678这种。听说这也是某个企业的面试题，闲来无事就着手实现一下。我先用了C++进行实现，后来换一种思路用了Python实现，最后采用了更为简单的正则表达式，并对负数、小数都加以实现。 C++实现&emsp;&emsp;&ensp;由于笔者是个菜鸡，平时很少编程，C++还是大一的时候学了点皮毛，现在基本忘了差不多了🌚，所以用的很不熟练，下面是我实现千位分割问题的代码，如果有可以改进的地方，欢迎指出😉。 1#include &lt;iostream&gt; using namespace std; int main() &#123; int num,len=0,extra,temp; int level=1; cout &lt;&lt; "请输入一个数："; cin &gt;&gt; num; //计算输入数字的位数 temp = num; while(temp&gt;0) &#123; temp /=10; len++; level *=10; &#125; extra = len%3; //超出3的倍数位的位数 //输出带有千位分隔符的数字 int k=0; while(len&gt;0) &#123; level /=10; cout &lt;&lt; char(num/level+'0'); //输出每一位 num %= level; k++; extra--; len--; if((extra == 0 &amp;&amp; len &gt; 2) || (k == 3 &amp;&amp; len &gt;0)) &#123; cout &lt;&lt; ","; k = 0; &#125; &#125; &#125; 运行结果 Python实现&emsp;&emsp;&ensp;用C++实现这一简单的问题还是要费一点事的，所以我又转用Python进行了实现，这里我主要是把字符串转变为列表进行了处理。 1234567891011num = input("请输入一个数：")L =list(num) #转变为列表num_length = len(num) #数字的位数start = num_length%3 #超出3的倍数位的位数index = list(range(start,num_length,3)) #需要插入","的索引值step =0for i in index: if i &gt;0: L.insert(i+step,',') step = step+1print("".join(L)) #列表转字符串 运行结果 正则表达式实现&emsp;&emsp;&ensp;读者可能已经发现了，我上述代码的实现对输入的数都要求是正数、整数，要实现正数负数，小数整数都能使用的话，还是需要添加部分代码的，于是这里使用正则表达式来进行实现。&emsp;&emsp;&ensp;据说熟练掌握正则表达式可以节省上百行代码🤔，哈哈，由于这里的问题比较简单，不能充分体现出正则表达式的优势。而且Python的正则表达式引擎是用 C 语言写的，所以效率是十分高，并且几乎所有的字符串任务均可用正则表达式来实现，所以掌握正则表达式是十分有必要的，大家有时间可以去学习一波🤓。下面就贴出我的代码： 123456789num = input("请输入一个数：")m = re.search('\.', num)if m == None: #如果是整数 result = re.sub(r"(?&lt;=\d)(?=(\d&#123;3&#125;)+$)", ",", num)else: #如果是小数 inte, dec = re.split('\.', num) #整数、小数分开处理 inte = re.sub(r"(?&lt;=\d)(?=(\d&#123;3&#125;)+$)", ",", inte) result = inte + '.' +dec #合并print(result) 运行结果&emsp;&emsp;&ensp;可以发现，该程序对负数、小数都能实现千分位分割。正则表达式好处自然很明显，劣势就是不易读，如果不是很熟悉的话很难快速理解该表达式的意思，这里 (?&lt;=\d) 的意思是匹配项前面要有数字，而 (?=(\d{3})+$) 的意思是匹配项后面到结束符要有3的倍数个数字，需要注意的是这里的匹配不消耗字符串的内容，所以原本用作替换的sub函数相当于实现了插入的功能。 后记&emsp;&emsp;&ensp;从上面不同方法的实现，可以看出正则表达式在处理字符串方面的优势，由此可见正则表达式是一个十分重要的技能。其实，像千位分割这种常见的操作，Python怎么会没有函数能够一步到位实现呢🤔？果然，查阅资料后发现，format函数就可以实现这一功能。 1print(format(-123456789.12345,',')) 这样就完事啦，是不是非常简单🌚，不过笔者在这里主要是为了强调正则表达式的优势哈哈哈😁，并且这种难读的表达式还需要多多操作啊。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Image Joint]]></title>
    <url>%2F2018%2F11%2F19%2FImage-Joint%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&ensp;最近刚学完数字图像处理这门课程，闲来无事，就想编一个图片拼接的程序，代码很简单，如下 源代码123456789101112131415161718192021222324252627282930313233343536373839404142import PIL.Image as imimport osIMAGES_PATH = '/Users/sunxin/Desktop/jointtst' # 存放图片的文件夹地址IMAGES_FORMAT = ['.jpg', '.JPG','.jpeg', '.JPEG','.png','.PNG'] # 图片扩展名IMAGE_HEIGHT = 400 # 每张小图片的高IMAGE_WIDTH = 400 # 每张小图片的宽IMAGE_ROW = 3 # 合成图片的行IMAGE_COLUMN = 3 # 合成图片的列IMAGE_SAVE_PATH = '/Users/sunxin/Desktop/jointtst/final/nba_logo.jpg' # 图片合成后保存的地址# 获取图片集地址下的所有图片名称image_names = [name for name in os.listdir(IMAGES_PATH) for item in IMAGES_FORMAT if os.path.splitext(name)[1] == item]'''Tips：os.path.splitext()将文件名和扩展名分开os.path.split()返回文件的路径和文件名'''# 若文件夹中所含图片数目不等于期望拼接的图片数目，报错if len(image_names) != IMAGE_ROW * IMAGE_COLUMN: raise ValueError("请核对需要拼接的图片数目！")# 图像拼接函数def Image_joint(): to_image = im.new('RGB', (IMAGE_COLUMN * IMAGE_WIDTH, IMAGE_ROW * IMAGE_HEIGHT)) # 创建一个新图 # 循环遍历，把每张图片按顺序粘贴到对应位置上 for y in range(IMAGE_ROW ): for x in range(IMAGE_COLUMN): from_image = im.open(os.path.join(IMAGES_PATH,image_names[IMAGE_COLUMN * y + x])).resize( (IMAGE_WIDTH, IMAGE_HEIGHT), im.ANTIALIAS) to_image.paste(from_image, (x * IMAGE_WIDTH, y * IMAGE_HEIGHT)) return to_image.save(IMAGE_SAVE_PATH) # 生成新图'''Tips：注意os.path.join和直接使用字符串'+'的区别（少一个'/'）NEAREST（使用最近邻居）BILINEAR（2x2环境中的线性插值）BICUBIC（4x4环境中的三次样条插值）ANTIALIAS（高质量的下采样滤波器）paste函数的参数为(需要修改的图片，粘贴的起始点的横坐标，粘贴的起始点的纵坐标）'''Image_joint() 实现效果&emsp;&emsp;&ensp;我是将九张不同NBA球队的logo拼接成一个九宫格的形式，拼接前，各个文件如下：&emsp;&emsp;&ensp;运行之后，可将新生成的图片保存到final文件夹之下，得到拼接后的图片为：&emsp;&emsp;&ensp;这样就完成了图片的拼接。需要注意的是，这九张图的大小不一定需要完全一样，我的这九张图的分辨率就不一样，程序中用插值法统一将每个图片的大小重新调整为400*400，于是可以很容易对调整后的图片进行操作。不同的插值法得到的效果不一样，这里采用的是高质量的下采样滤波器。由于原来九张图的高和宽原本不一定相同，现在全部调整为400，所以导致了有些logo看起来被拉高或者是拉宽了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bias-variance]]></title>
    <url>%2F2018%2F11%2F18%2Fbias-variance%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&ensp;昨天看书看到了“偏差和方差”这个字眼，想了一会心中没有得出确切的答案，明明前一阵子才在西瓜书中看过相关概念，现在知识点已经模糊，不仅感叹重温的必要性🌚，于是又把书翻出来重看了一遍，并决定把这块知识点写成博客，加强自己的理解和记忆。在写博客的过程中，我又上网查阅了相关的知识点，看了别人的博客，收获了和书中不一样的解释方式，结合图形更易理解，所以啊，写博客还是颇有收获的😁。 基本概念&emsp;&emsp;&ensp;这一部分我参考的是周志华的西瓜书，书中是通过对期望泛化误差的分解，用公式的推导进而解释偏差、方差以及噪声的概念。这里，我不作推导，但仍用书中的符号进行表示，首先给出相关概念的符号表示 符号 含义 $\boldsymbol x$ 测试样本 $ D $ 训练集 $y_D$ $\boldsymbol x$在数据集中的标记 $y$ $\boldsymbol x$的真实标记 $f(\boldsymbol x;D)$ 训练集$D$上学得模型$f$在$\boldsymbol x$上的预测输出 $\hat{f}(\boldsymbol x)$ 期望预测 $var(\boldsymbol x)$ 使用样本数相同的不同训练集产生的方差 $\epsilon^2$ 噪声 $bias^2(\boldsymbol x)$ 偏差 其中，学习算法的期望预测为 \hat{f}(\boldsymbol x) = E_D[f(\boldsymbol x;D)]算法的期望泛化误差为 E(f;D) = E_D[(f(\boldsymbol x;D)-y_D)^2]假定噪声期望为零，即 E_D[y_D-y] = 0对泛化误差进行分解，最终可以得到 E(f;D) = E_D[(f(\boldsymbol x;D)-\hat{f}(\boldsymbol x))^2]+(\hat{f}(\boldsymbol x)-y)^2+E_D[(y_D-y)^2]于是， E(f;D) = bias^2(\boldsymbol x)+var(\boldsymbol x)+\epsilon^2也就是说，泛化误差可以分解为偏差、方差与噪声之和。 再来看偏差、方差、噪声它们各自的含义： 偏差：bias^2(\boldsymbol x)=(\hat{f}(\boldsymbol x)-y)^2度量了学习算法的期望预测与真实结果的偏离程度，刻画了学习算法本身的拟合能力。 方差 ：var(\boldsymbol x)=E_D[(f(\boldsymbol x;D)-\hat{f}(\boldsymbol x))^2]度量了同样大小的训练集的变动所导致的学习性能的变化，刻画了数据扰动所造成的影响。 噪声：\epsilon^2=E_D[(y_D-y)^2]表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，刻画了学习问题本身的难度。&emsp;&emsp;&ensp;综上，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的，为了取得好的泛化性能，需要使偏差较小，能够充分拟合数据，也要使方差较小，使得数据扰动产生的影响小。 &emsp;&emsp;&ensp;以上是我在书中获得的解释，后来我又在某些博客中看到了更加直观的图形解释。&emsp;&emsp;&ensp;如图，我们可以使用靶心图创建偏差和方差的图形可视化。目标的中心是一个完美预测正确值的模型，随着我们远离靶心，我们的预测变得越来越糟，我们可以重复整个模型构建过程，以便在目标上获得许多单独的命中。有时我们会得到很好的训练数据分布，所以我们预测得很好，且接近靶心，而有时我们的训练数据可能充满了异常值或非标准值，导致预测较差，这些不同的实现导致目标上的命中分散。 偏差-方差窘境&emsp;&emsp;&ensp;一般，偏差和方差是有冲突的，称为偏差-方差窘境（bias-variance dilemma）在训练不足时，学习器的拟合能力不够强，训练数据的扰动不足以使学习器产生显著变化，此时偏差主导了泛化错误率。随着训练程度的加深，学习器的拟合能力逐渐增强，训练数据发生的扰动渐渐能被学习器学到，方差逐渐主导了泛化错误率。训练程度充足后，学习器的拟合能力已非常强，训练数据发生的轻微扰动都会导致学习器发生显著的变化，若训练数据自身的、非全局的特性被学习器学到了，则将发生过拟合。下面的这张图正好说明了这点&emsp;&emsp;&ensp;其实，处理偏差和方差实际上是关于处理过度拟合和欠拟合。随着越来越多的参数被添加到模型中，模型的复杂性上升，变化成为我们首要关注的问题，所以方差变大，而偏差则逐渐下降。&emsp;&emsp;&ensp;正如上一节的那张图所示，欠拟合实际上对应的是高偏差，而过拟合对应的又是高方差。而我们的目的是要寻找使得泛化误差取得最小值的那个最佳点，这就需要让偏差和方差在一定程度上折中取值。 偏差-方差折中&emsp;&emsp;&ensp;很多算法都是可以控制训练程度的，比如决策树可以控制层数，神经网络可以控制训练轮数，集成学习的方法可控制基学习器的个数。&emsp;&emsp;&ensp;我看到偏差-方差折中这一概念是在《机器学习实战》这本书中遇到的，那一章节主要讲了回归。书中提到，线性回归容易发生欠拟合，因为它求的是具有最小均方误差的无偏估计，而我们可以在估计中引入一些偏差用来降低预测的均方误差，有一个方法就是局部加权线性回归。这里不作介绍，感兴趣的小伙伴可以阅读《机器学习实战》的8.2节，得出的结论是选取的核越小，模型复杂度就越高，可以增大方差减小偏差。而当模型十分复杂以至于发生了过拟合时，可以采用缩减法，将一些系数进行缩减，可以减少模型的复杂度，降低方差。书中8.3节和8.4节主要介绍了岭回归、lasso法和前向逐步回归法这些缩减方法，并且结合实例进行了分析，感兴趣的小伙伴可以详细阅读。 后记&emsp;&emsp;&ensp;花了点时间，总算对偏差和方差的概念又加深了一遍印象，以后还是要注意温故而知新呐🌝。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Decorate my Blog]]></title>
    <url>%2F2018%2F11%2F16%2FDecorate-my-Blog%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;&ensp;折腾了两天总算把自己的博客装饰地像个样子了🙃，现在就来整理一下借鉴了哪些资料吧。&emsp;&emsp;&ensp;一篇来自CSDN，一篇来自简书，两篇介绍的都是NexT主题的使用，介绍的设置功能比较多，笔者因为懒癌晚期就选了几个自己觉得还不错的进行了实际操作，操作过程中发现两个都有点小毛病，但是结合起来，再加上自己的摸爬滚打，还是可以成功地把自己的博客装饰的像个样的🌚。&emsp;&emsp;&ensp;上面两篇文章提到的网易云跟帖已经关闭，改用了来必力，不过我对此不是很感兴趣……jiathis分享目前也停止了服务，但是百度当然依旧坚挺……多说评论也被勒令停止服务，可以改用Gitment进行评论功能的实现。还有还有，统计全站总访问量的不蒜子，因为七牛强制过期原有的域名，现在也改了操作，不过很简单，直接看解决方法。另外，笔者在设置头像的过程中，跟着上面两篇的介绍虽然设置了美美的头像🤓，但换了一台电脑居然无法显示，于是又借鉴了这篇文章，把问题解决了。&emsp;&emsp;&ensp;还有很多功能都没尝试操作，感兴趣的小伙伴们可以再折腾一波😁。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Chat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[F107 Calculate]]></title>
    <url>%2F2018%2F11%2F14%2FF107-Calculate%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;&ensp;首先，要说明的是这只一个很简单的小任务，只涉及到简单的数据处理，界面设计和可执行文件的生成。那么，为什么笔者能长篇大论地写出这么多废话呢🌝，一是刚搭建好自己的博客，心血来潮、三分钟热度，想把自己的第一篇博客写的像个样子🙃，二来也是为了熟悉熟悉Markdown这个很好的写作语言，锻炼锻炼表达能力和总结能力，三来就是因为太闲了，学习是不可能学习的，这辈子都不想学习，只能写写博客找点事做给自己心灵一点安慰🌚。好了，下面就开始说说我这个小任务吧。 背景&emsp;&emsp;&ensp;由于项目设计被随机分到了一个做微波方向的老师那，有了个比较高大上的项目名称——超材料阵列天线及其在射电望远镜中的应用🤔。当然，对于没学过微波、天线等各种专业课的渣渣，拿到这个题目肯定是一脸懵逼🌚，万幸老师了解到我的研究生方向是图像处理，于是给我先分配了一个数据处理的任务。废话不多说，这次的任务是根据按照某种规则存放在文件中已经测得的数据，通过公式计算得到太阳射电指数F107，那么先简单介绍一下这个高大上的名词吧🙃。 关于F107&emsp;&emsp;&ensp;太阳F107指数，就是太阳10.7厘米波长（2800-2840MHz，视无线电环境而定）的射电辐射通量，是表征太阳活动水平的一个重要参量，和黑子的变化具有很高的相关性，足以反映太阳长期活动和日地效应的变化。其单位为S.F.U（太阳流量单位，Solar Flux Unit），1S.F.U=10-22w Hz-1m-2，其一般范围在60到300之间。平均F107指数高于180的年份称为典型的太阳活动峰年，平均F107指数低于90的年份称为典型的太阳活动谷年。因此，常用F107 指数划分太阳活动的总体水平。&emsp;&emsp;&ensp;目前国家气象局卫星气象中心在山东荣成石岛建有能观测F107指数的太阳射电望远镜，定标过程分为三个步骤：第一步： 天线对准太阳跟观测记录数据；每3分钟形成一个数据文件；第二步： 天线偏离太阳两度，并开启噪声源记录3分钟，形成一个文件；第三步： 接收机关闭噪声源，并记录数据3分钟，形成一个文件；&emsp;&emsp;&ensp;执行完上述三步后，噪声源关闭，天线重新对准太阳进行跟踪。上述步骤分别在每天观测的9:00、12:00:和15：00进行三次。&emsp;&emsp;&ensp;然后，我们就可以从每天的观测文件中提取出三个信息量，分别是：$ R_S $（太阳）、$ R_N $（噪声源）、$ R_B $（冷空），再通过公式: S=S_0（R_S—R_B）/（R_N）就可以求得太阳射电流量，其中$ S_0 $为修正系数。&emsp;&emsp;&ensp;说了这么多，你可能一头雾水，没事，我也什么都不懂🌚，但是我们的任务很简单，就是通过简单的文件操作，把测得的数据整理成自己想要的模样，再通过上述提到的非常简单的公式计算出$ S_0$，通过长期的$ S_0 $得到最佳的修正系数，由于老师只给了我几天有用的测量数据 (其实给了一堆，后来发现很多天机器在维修，数据都没有用🙃)，我就直接采取求平均值的方法得到了看似最佳的最佳修正系数🌝，数据多的话可以采用机器学习的方法，当然，不在本文的讨论范围内，最后再把写好的文件生成一个在其他电脑上可执行的exe就OK了(博主用的是Mac，所以生成的是OS系统下的APP，后续也会提及exe和APP的生成方法)。 任务要求及描述&emsp;&emsp;&ensp;现在，我们可以从空间环境预报中心查询到每天的F107指数，然后就可以通过石岛望远镜观测的每天记录数据，求得本望远镜系统的$S_0$参数，并统计长期的$S_0$的稳定性情况，最后求得最佳$S_0$，用于石岛望远镜每天自动计算F107指数。另外，要求有自动导入数据分析功能，即生成一个exe文件，通过选择文件夹的方式导入一天的所有观测数据，直接计算出当天的F107指数$ S $，并显示在屏幕上。&emsp;&emsp;&ensp;那么，我得到的原始数据是什么样的呢？老师给我发了一个文件夹，记录了今年10月1日至11月6日的所有观测数据(emmm，后来发现由于机器故障，只有10月25日至11月6日的数据可用🌚) &emsp;&emsp;&ensp;打开这个文件夹就惊了，竟然包含了7350个txt文件……先来看看这些文件是怎么命名的吧，随便选取一个 &emsp;&emsp;&ensp;前面一串英文是什么？这不重要，我门只需关注中间的一段数字即可，这个文档的数字是20181101144002，表示的是这是2018年11月01日14时40分02秒生成的记录数据文件，文件中包含了大约三分钟的记录数据。我们再将这个文档打开，哇，又是一堆数据，我们截取部分&emsp;&emsp;&ensp;好了，这些数据具体是什么意思呢？我也没关注一共有多少行，反正就是3分钟左右的数据量就是了，显而易见，第一列数据表示的年月日，第二列表示的时分秒，第三列我也不晓得是啥，反正不重要😂，4、5、6列就是我们记录的数据，分别是在2801MHz±5MHz, 4554MHz±5MHz以及9081MHz±5MHz的采集数据，根据之前F107指数的介绍，我们这里只需关注第4列数据，至于最后一列数据，既然用不到，管它干啥🙃。那么，这么多的记录数据，哪些是太阳数据$ R_S $，哪些是噪声源数据$ R_N $，又是哪些是冷空数据$ R_B $呢？咨询过老师得知，每天的9：00：00-9：02：59，12：00：00-12：02：59，15：00：00-15：02：59的所有数据是噪声源数据$ R_N $，9：03：00-9：05：59，12：03：00-12：05：59，15：03：00-15：05：59的所有数据是冷空$ R_B $，其余的所有数据是太阳数据$ R_S $，这下思路就很明了了，只需提取出当天的$ R_S $、$ R_N $和$ R_B $，那么什么问题都不在话下🤓。 思路及实现&emsp;&emsp;&ensp;先给出我的代码，很简单，都是基础的Python，稍微难懂的都加了注释，所以这里就只提个思路就好。由于笔者刚接触Python没多久，所以很多地方都没有优化，写的不好请见谅😉。哦哦，至于老师发给我的那些观测数据，因为老师说那是机密文件🤔，所以我就不上传了吧😂。 数据处理&emsp;&emsp;&ensp;首先，我们要将这些堆杂在一起的文档按日期进行整合，即把属于一天的所有数据合并到一个文件中，形成这样的一种形式&emsp;&emsp;&ensp;实现起来很简单，我代码中的CombFile( )函数就实现了该功能，后来，老师给我说当时给我的文件是特殊情况🌚，以后需要处理的数据如下面这种样式，即已经按日期分类好，但没有进行整合&emsp;&emsp;&ensp;没事，那样更简单，我的CombFile02( )就实现了整合的功能。整合得到当天的testdata之后，那么一切都变得简单了，函数GetR( )将数据进行划分，得到当天所有的$ R_S $、$R_N$和$ R_B $数据，函数calS0( )再根据$ S $和$ S_0 $之间的公式关系，以及官网查得的数据$ S $，即可计算得出当天的$ S_0 $，计算出多天的$S_0$，我们这里就简单地去个平均，作为我们的最佳修正系数，之后，再用函数PredictS( )，也就是calS0( )的逆过程，把最佳修正系数作为当天的$ S_0 $，就可以预测出当天的$ S $，可以和官网公布的数据进行比较，看看误差，当然，由于训练样本太小，仅仅采用取平均的方法，误差肯定有些偏大🌚，没事……笔者不在乎，重在体验😂。&emsp;&emsp;&ensp;哇，到这里数据处理部分就这么结束了？可见这个项目是有多简单🌝，我还在这里兴致勃勃地长篇大论……好了，下面就剩下用户界面和生成一个可执行文件了。 用户界面&emsp;&emsp;&ensp;这里主要用的Python自带的tkinter库，在制图方面很有用，有兴趣的朋友可以自己学习一个。我们这里用到的就很简单了，一个Button产生按钮，filedialog用作显示对话框，提示用户打开文件夹，最后再用messagebox来显示计算结果就OK了。我们运行一下看看是什么样子&emsp;&emsp;&ensp;可以看到出现了一个对话框，然后我们点击对话框中的按钮，就可以进行选择文件夹了&emsp;&emsp;&ensp;随意选取一个文件夹，就可以计算出结果啦！&emsp;&emsp;&ensp;结果是多少不重要，反正是实现了任务要求了🤓。好了一个简单的项目到此就基本结束了，下面就来生成一个可执行的文件，可以用于其他没有安装Python及相关库的上位机中。 生成可执行文件Mac OS系统&emsp;&emsp;&ensp;这一块我是实在不想写的……捣鼓了那么久最后也没捣鼓出来，主要用到的是py2app，看了很多博客、论坛，都是大同小异，可以根据这篇操作一波，当然里面是没有涉及到遇到的各种bug的，如果你能一帆风顺地完成，emmm那么就很简单了😂。期间我遇到了各种奇葩的bug，不知道是环境还是啥问题，找了小伙伴来也没能解决，最后自己一顿骚操作，居然生成了一个APP，把我激动地半天，我还给这个APP加了一个图标，附加了其他相关信息&emsp;&emsp;&ensp;最后发现这玩意只能在我的Mac上运行，在其他的Mac上就GG了🌚，不管了，放弃了，我就是这么懒🙃。&emsp;&emsp;&ensp;有兴趣的小伙伴可以跟着教程操作一波，简书里的这篇文章写的就很详细了，介绍了如何添加图标，加入版本，版权等信息。另外推荐一个网站，里面有很多有趣的图标可供选择。 Windows系统&emsp;&emsp;&ensp;在Mac OS系统下倒腾失败后，我又开始倒腾Windows……查阅相关介绍后，发现在Windows下有两种生成方式，一个就是和py2app很像的py2exe了……网上介绍很简单，但是有心理阴影的我又没搞出来🙃，后来发现py2exe已经十多年没更新了……出各种bug可能也是难免的吧。所以当然就要推荐第二种方法了——pyinstalller，真的是简单又方便，同样，这里也包含了很多命令可以添加图标之类的各种信息。当然，要想把图标做的更完美，还是需要修改一些文件内容的，可以综合参考一下这篇文章和这一篇，最终，我终于生成了一个exe&emsp;&emsp;&ensp;第一张图是文件存放在桌面或者文件夹中的显示图标。第二张图是运行之后的对话窗口，同样具有按钮，细心的小伙伴还会发现在对话窗口的左上角还有一个小太阳，没错，这就是完善图标后的效果，对应的就是第三张图在任务栏中显示的图标，同样也是一个小太阳。于是在Windows下的可执行文件就生成啦。&emsp;&emsp;&ensp;在其他上位机测试过也可以执行，终于完事了……天呐，我实在太菜了，捣鼓了这么久才弄出来🌚，没事，重在折腾…… 后记&emsp;&emsp;&ensp;把可执行文件发给老师之后也就算完成任务了，闲下来的我花了点时间学了点GitHUb，又搭了一个HEXO博客，然后写下了这篇废话连篇的博客。这篇博客断断续续竟然写了两天，真的敬佩那些坚持每周一更的大牛们，而且还是高质量的文章，自己也不晓得能不能坚持……emmm，继续努力吧😂，未来的路还很长，道阻且长，行则将至，共勉。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FirstBlog]]></title>
    <url>%2F2018%2F11%2F13%2FFirstBlog%2F</url>
    <content type="text"><![CDATA[&emsp;哈哈哈，终于把HEXO搭建好啦！！！👏👏👏&emsp;这两天学习了一下Markdown，GitHub的基本操作，并搭建好了HEXO，过会再学习一下HEXO的使用。😉&emsp;几天主要跟着从0开始学习GitHub系列学习的是这篇文章，作者张帅写的很好呐，受益匪浅，作为一个即将毕业的大四🐶，感觉真的是相见恨晚呐。文章写的这么好，想必人一定很帅吧（手动狗头）哈哈哈。&emsp;先说这么多，明早还要早起上一周里唯一的一节课，哈哈，身为大四🐶唯一早起的理由了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Chat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Chat</tag>
      </tags>
  </entry>
</search>
